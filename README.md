# java-interview-questions

### 1. What are the key features of Java?

Java is a widely-used, high-level programming language known for its versatility, performance, and platform independence. Below are the key features of Java:

**1. Platform Independence**
* Java uses the "**Write Once, Run Anywhere" (WORA)** principle.
* Programs written in Java are compiled into **bytecode**, which can run on any system with a Java Virtual Machine (JVM), regardless of the underlying operating system or hardware.

**2. Object-Oriented Programming (OOP)**
*    Java is based on OOP principles like encapsulation, inheritance, and polymorphism.
*    It allows developers to model real-world entities, improving code reuse and maintainability.

**3. Simple and Easy to Learn**
*    Java has a clean syntax derived from C and C++, but without complex features like explicit pointers and memory management.
*    The automatic garbage collection simplifies memory management.

**4. Robust**
*    Java provides strong memory management, exception handling, and type-checking mechanisms to ensure fewer runtime errors.
*    Its automatic **garbage collector** helps prevent memory leaks.

**5. Secure**
- Java provides built-in security features like:
  *    **Bytecode verification:** Ensures code adheres to Java's rules.
  *    **Classloader:** Separates the loading of classes from the local filesystem.
  *    **Security manager:** Defines access controls for Java applications.

**6. Multithreading**
*    Java supports concurrent execution of multiple threads, allowing better utilization of CPU resources.
*    Its built-in thread model simplifies writing multi-threaded applications.

**7. Distributed Computing**
*    Java provides APIs like **RMI (Remote Method Invocation)** and **CORBA**, enabling the development of distributed applications.

**8. High Performance**
*    While Java is an interpreted language, the **Just-In-Time (JIT) Compiler** converts bytecode to native machine code at runtime, improving performance.

**9. Portability**
*    Java programs are hardware and OS-independent due to its bytecode and JVM architecture.
*    The standard library provides a consistent programming environment across different platforms.

**10. Dynamic and Extensible**
*    Java can dynamically link libraries and objects at runtime, making it more adaptable to evolving environments.
*    It supports **dynamic loading of classes**.

**11. Rich Standard Library**
- Java comes with an extensive set of libraries for various functionalities:
  *    **Data structures:** Collections Framework
  *    **I/O operations:** java.io, java.nio
  *    **Networking:** java.net
  *    **Concurrency:** java.util.concurrent
  *    **Database access:** JDBC (Java Database Connectivity)

**12. Scalability**
*    Java is well-suited for both small-scale applications (e.g., desktop programs) and large-scale enterprise systems (e.g., web servers and microservices).

**13. Support for Functional Programming**
- Java 8 introduced functional programming features like:
  *    Lambda expressions
  *    Streams API for processing collections
  *    Method references

**14. Tooling and Ecosystem**
*    A wide range of tools (Eclipse, IntelliJ IDEA, Maven, Gradle) supports Java development, deployment, and testing.
*    Frameworks like Spring, Hibernate, and JUnit enhance development productivity.

**15. Backward Compatibility**
*    Java maintains compatibility between versions, ensuring older applications run seamlessly on newer Java versions with minimal changes.

**16. Community and Support**
*    Java has a vast and active developer community, providing extensive resources, libraries, and frameworks.

### 2. What is the difference between JDK, JRE, and JVM?

The terms **JDK**, **JRE**, and **JVM** are essential components of the Java ecosystem. While they are interrelated, they serve distinct purposes. Here's a detailed explanation of each and their differences:

**1. JVM (Java Virtual Machine)**
- **Definition**: The JVM is the runtime engine that executes Java bytecode. It is responsible for providing an environment in which Java programs can run.
- **Key Responsibilities:**
  *   Converts **bytecode** (generated by the compiler) into machine-specific instructions.
  *   Handles **memory management** via Garbage Collection.
  *   Ensures platform independence by providing a layer of abstraction over the underlying hardware/OS.
- **Components:**
  - **Class Loader:** Loads class files into memory.
  - **Execution Engine:** Interprets or compiles bytecode to machine code (via JIT Compiler).
  - **Runtime Data Area:** Includes heap, stack, method area, and more.
  - **Platform Independence:** JVM ensures the Write Once, Run Anywhere (WORA) principle by abstracting the OS-specific implementation.

**Analogy:** **JVM is like a virtual machine that runs compiled Java programs, regardless of the underlying hardware.**

**2. JRE (Java Runtime Environment)**
- **Definition:** JRE provides the necessary runtime environment to execute Java applications. It includes the JVM and essential libraries required for running programs.
- **Components:**
  - **JVM**: Executes Java bytecode.
  - **Java Libraries**: Pre-built class libraries like java.lang, java.io, java.util, etc.
  - **Other Supporting Files**: Configuration and resource files for execution.
- **Usage**: If you're only running Java applications (not developing), you only need the JRE.
     
**Analogy: JRE is like the engine in a car, providing everything needed to drive (run) it.**


**3. JDK (Java Development Kit)**
* **Definition:** The JDK is a complete software development kit for Java, including the tools needed to develop, compile, debug, and run Java applications.
* **Components:**
  - **JRE**: For running Java applications.
  - **Development Tools**:
     - **javac**: Java compiler (converts Java code to bytecode).
     - **javadoc**: Documentation generator.
     - **jar**: Tool for packaging Java applications.
     - Debuggers, profilers, and other tools.
- **Usage:** Required for developers who want to write and compile Java code.

**Analogy: JDK is like a toolbox containing everything needed to build, debug, and run Java programs.**

![img_3.png](img_3.png)

### 3. Why is Java platform-independent?

Java is considered **platform-independent** because of its ability to run on any operating system or hardware without requiring changes to the code. This platform independence is achieved through the use of the **Java Virtual Machine (JVM)** and **bytecode**. Here’s a detailed explanation of how Java achieves platform independence:

**1. Compilation to Bytecode**
*    When a Java program is compiled, the Java compiler (**javac**) converts the source code (written in `.java` files) into an intermediate format called **bytecode** (stored in `.class` files).
*    **Bytecode** is a low-level, platform-neutral instruction set designed to be executed by the JVM.
   
**Key Point: Bytecode is not specific to any machine or operating system, making it universally portable.**

**2. Java Virtual Machine (JVM)**
*    The **JVM** is a runtime environment responsible for executing bytecode. It acts as an abstraction layer between the Java bytecode and the underlying hardware/operating system.
*    Each platform (Windows, macOS, Linux, etc.) has its own implementation of the JVM, tailored to that specific platform. However, the bytecode remains the same across all platforms.
*    The JVM translates bytecode into **machine-specific instructions** at runtime, allowing the program to run on any system with a JVM.
   
**Key Point: The JVM ensures that the same bytecode can run on any platform without modification.**

**3. "Write Once, Run Anywhere" (WORA) Principle**
- Java’s design philosophy is **"Write Once, Run Anywhere"**:
   - Developers write Java code once.
   - The compiled bytecode can be executed on any platform that has a compatible JVM.

**Key Point: The JVM handles all platform-specific details, enabling the same program to run seamlessly across different environments.**

**4. Standard Libraries**
*    Java includes a rich set of **standard libraries** (e.g., java.io, java.util, java.net) that abstract platform-specific operations like file handling and networking.
*    These libraries ensure that developers don’t have to worry about differences between operating systems.

**Key Point: Java provides a consistent programming environment, regardless of the platform.**

**5. Cross-Platform Development Tools**
- Java development tools like the **JDK** and frameworks like Spring further support platform independence by standardizing the development and deployment process across different systems.

**Platform Independence Workflow**
1. Write Java code in a `.java` file.
2. Compile the code with the **Java compiler** (javac) to produce platform-independent bytecode (`.class` file).
3. Run the bytecode on any platform using the **JVM** for that platform.

**Examples of Platform Independence**
* A `.class` file compiled on Windows can run on Linux or macOS without modification, as long as the target system has a compatible JVM.
* Enterprise applications written in Java can run on any server environment (e.g., AWS, Azure, or on-premises systems), making Java a popular choice for distributed systems and microservices.


### 4. What is the purpose of the main method?
The **main method** in Java is the **entry point** of any standalone Java application. It is where the **JVM (Java Virtual Machine)** starts program execution. Without a `main` method, the program cannot run as a standalone application.

The `main` method in Java serves as the **starting point** of the application. It is:

1. A special method recognized by the JVM for program execution.
2. Used to pass and process command-line arguments.
3. Essential for creating standalone Java applications.
```java
public static void main(String[] args) {
    // Program logic here
}

```
![img_4.png](img_4.png)
**Example: Main Method with Command-Line Arguments**
```java
public class MainExample {
    public static void main(String[] args) {
        if (args.length > 0) {
            System.out.println("First Argument: " + args[0]);
        } else {
            System.out.println("No arguments provided.");
        }
    }
}

```
**Execution**
1. Run the program:
```
java MainExample Hello

```
2. Output:
```
First Argument: Hello

```

### 5. What is the difference between static, final, and abstract?
In Java, `static`, `final`, and `abstract` are keywords that serve distinct purposes in the language. Here's a detailed comparison of their differences:

1. `static`
   - **Purpose:** Used to define variables, methods, or blocks that belong to the class rather than to any specific instance of the class.
   
   **Key Features:**
![img_5.png](img_5.png)

**Example:**
```java
class Example {
    static int count = 0; // Static variable

    static void displayCount() { // Static method
        System.out.println("Count: " + count);
    }

    static { // Static block
        System.out.println("Class loaded!");
    }
}

```
- **Usage:**
  *    To share data among all instances of a class (e.g., counters, configuration values).
  *    Utility methods like `Math.sqrt()` are often `static`.

2. `final`
- **Purpose:** Used to declare constants, prevent method overriding, or restrict inheritance.
![img_6.png](img_6.png)

**Example**
```java
final class FinalClass { // Final class
    final int value = 42; // Final variable

    final void displayValue() { // Final method
        System.out.println("Value: " + value);
    }
}

```
- **Usage:**
    - To define constants (`final int MAX_VALUE = 100;`).
    - To secure methods or classes from being modified in subclasses.

3. `abstract`
   **Purpose**: Used to define a blueprint for classes, methods, or concepts without providing a complete implementation.

![img_7.png](img_7.png)

**Example**
```java
abstract class Shape { // Abstract class
    abstract void draw(); // Abstract method (no body)
}

class Circle extends Shape {
    void draw() { // Implementation of abstract method
        System.out.println("Drawing a Circle");
    }
}

```

- **Usage:**
    - When creating a base class that provides partial functionality but requires subclasses to implement specific behaviors.

![img_8.png](img_8.png)

**Combination Usage**
- `final` and `static` together:
```java
static final int MAX_VALUE = 100; // Constant

```
- `abstract` and `static` cannot be used together:

    - A `static` method cannot be abstract because `static` methods belong to the class, while `abstract` methods must be implemented by subclasses.

### 6. Explain the difference between this and super.

In Java, `this` and `super` are keywords used in object-oriented programming to refer to the current object and the parent class, respectively. Here's a detailed explanation of their differences:

1. `this`
**Purpose:**
The `this` keyword refers to the **current instance** of the class. It is commonly used to:

   * Access instance variables when there is a naming conflict.
   * Call other constructors within the same class.
   * Pass the current instance as a parameter.
![img_9.png](img_9.png)

**Example**
```java
class Example {
    private int number;

    Example(int number) {
        this.number = number; // Resolves conflict between instance and parameter
    }

    void display() {
        System.out.println("Number: " + this.number); // Refers to the current instance variable
    }

    Example() {
        this(42); // Calls the other constructor
    }
}

public class Main {
    public static void main(String[] args) {
        Example example = new Example();
        example.display();
    }
}

```
**Output**
```
Number: 42

```
2. `super`
**Purpose**:
The `super` keyword refers to the **parent class (superclass)** of the current object. It is commonly used to:

   * Access parent class members (fields or methods) that are hidden in the subclass.
   * Call the parent class constructor.
   * Invoke a method from the parent class that has been overridden.

![img_10.png](img_10.png)

**Example**
```java
class Parent {
    String name = "Parent";

    Parent() {
        System.out.println("Parent Constructor");
    }

    void show() {
        System.out.println("Parent Method");
    }
}

class Child extends Parent {
    String name = "Child";

    Child() {
        super(); // Calls the Parent constructor
        System.out.println("Child Constructor");
    }

    void show() {
        super.show(); // Calls the Parent's show() method
        System.out.println("Child Method");
    }

    void displayNames() {
        System.out.println("Parent name: " + super.name); // Access Parent's name
        System.out.println("Child name: " + this.name);   // Access Child's name
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.show();
        child.displayNames();
    }
}

```
**Output**
```
Parent Constructor
Child Constructor
Parent Method
Child Method
Parent name: Parent
Child name: Child

```
![img_11.png](img_11.png)

### 7. What are Java’s access modifiers?

Java's **access modifiers** are keywords used to set the level of access to classes, methods, and variables. They control visibility and accessibility in the object-oriented programming paradigm.

**1. Types of Access Modifiers**\
   Java provides four access modifiers:
![img_12.png](img_12.png)

**2. Access Modifier Details**\

`public`
  *    **Visibility**: Accessible from **anywhere** (within the same class, package, or outside the package).
  *    **Usage**: Used for methods, variables, and classes that need to be universally accessible.
  *    **Example**

```java
public class PublicExample {
    public int value = 10;

    public void display() {
        System.out.println("Public Method");
    }
}

// Access from anywhere:
PublicExample obj = new PublicExample();
obj.display(); // Allowed

```
`protected`
* **Visibility**: Accessible within the **same package** and by **subclasses** in other packages.
* **Usage**: Commonly used in inheritance to allow access to child classes while hiding from the outside world.
* **Example**:

```java
class Parent {
    protected void show() {
        System.out.println("Protected Method");
    }
}

public class Child extends Parent {
    public static void main(String[] args) {
        Child obj = new Child();
        obj.show(); // Allowed (inherited method)
    }
}

```
`default` (**Package-private**, **no modifier specified**)
* **Visibility**: Accessible only within the **same package**. No keyword is required to define it.
* **Usage**: Used to limit access to classes and members within the package.
* **Example**:

```java
class DefaultExample {
    void display() { // No modifier means default
        System.out.println("Default Method");
    }
}

// Accessible only within the same package
DefaultExample obj = new DefaultExample();
obj.display(); // Allowed

```
`private`
* **Visibility**: Accessible only within the **same class**. Not visible to subclasses or other classes, even in the same package.
* **Usage**: Used to enforce encapsulation and restrict access to sensitive data or methods.
* **Example**:

```java
public class PrivateExample {
    private int value = 42;

    private void display() {
        System.out.println("Private Method");
    }

    public void accessPrivate() {
        display(); // Allowed (within the same class)
    }
}

// Access outside the class:
PrivateExample obj = new PrivateExample();
// obj.display(); // Not allowed
obj.accessPrivate(); // Indirect access allowed

```
**4. Access Modifier Usage in Classes**
* **Top-level classes**: Only public or default (package-private) modifiers are allowed.
* **Inner classes**: Can use public, protected, default, or private.

**Top-Level Class Example:**
```java
public class PublicClass {} // Allowed
class DefaultClass {} // Allowed
// private class PrivateClass {} // Not allowed

```
![img_13.png](img_13.png)

### 8. What is the difference between instance and local variables?
In Java, **instance variables** and **local variables** serve different purposes and have distinct scopes, lifetimes, and behaviors. Here's a detailed explanation of the differences:

**1. Instance Variables**
* **Definition**: Variables declared inside a class but outside any method, constructor, or block.
* **Scope**: Belong to an object (instance of a class) and are accessible throughout the class.
* **Lifetime**: Exist as long as the object exists in memory (until garbage collection).
* **Default Value**: Automatically initialized with default values (e.g., `0` for int, `null` for objects).
* **Access Modifiers**: Can be marked `private`, `public`, `protected`, or `default` to control accessibility.
* **Use**: Hold data that is specific to an instance of a class.

**Example**

```java
class Example {
    int instanceVariable = 10; // Instance variable

    public void display() {
        System.out.println("Instance Variable: " + instanceVariable);
    }

    public static void main(String[] args) {
        Example obj = new Example(); // Create an object
        obj.display(); // Access instance variable through object
    }
}

```
**2. Local Variables**
* **Definition**: Variables declared inside a method, constructor, or block.
* **Scope**: Exist only within the block/method where they are declared.
* **Lifetime**: Created when the block is executed and destroyed when the block exits.
* **Default Value**: Not initialized automatically; must be explicitly assigned a value before use.
* **Access Modifiers**: Cannot have access modifiers; always local to the block.
* **Use**: Store temporary data or control logic within a method or block.
   
**Example**:
```java
class Example {
    public void calculate() {
        int localVariable = 5; // Local variable
        System.out.println("Local Variable: " + localVariable);
    }

    public static void main(String[] args) {
        Example obj = new Example();
        obj.calculate(); // Access local variable within the method
    }
}

```
![img_14.png](img_14.png)

**4. Combined Example**
```java
class VariablesExample {
    int instanceVar = 10; // Instance variable

    public void show() {
        int localVar = 20; // Local variable
        System.out.println("Instance Variable: " + instanceVar);
        System.out.println("Local Variable: " + localVar);
    }

    public static void main(String[] args) {
        VariablesExample obj = new VariablesExample();
        obj.show();
        
        // System.out.println(localVar); // Error: localVar not accessible here
    }
}

```
**Output**

```
Instance Variable: 10
Local Variable: 20

```

### 9. What is the purpose of the package keyword?
The `package` keyword in Java is used to organize classes and interfaces into namespaces, making it easier to manage and structure code. It helps avoid naming conflicts, improves code reusability, and simplifies maintenance by logically grouping related classes.

**Purpose of the** `package` **Keyword**
1. **Organization of Code:**

* Packages group related classes and interfaces into a single namespace, making the codebase easier to navigate.
* Example: In a banking application, you might have packages like `com.bank.accounts` and `com.bank.transactions`.
2. **Avoidance of Naming Conflicts:**

* Without packages, different classes with the same name could lead to naming conflicts. Packages prevent this by providing a unique namespace.

Example
```java
com.company1.utils.Logger
com.company2.utils.Logger

```
3. **Access Control:**

* Packages help define the accessibility of classes and members using access modifiers like `default` and `protected`.
* Example: Classes in the same package can access each other’s `default` and `protected` members.

4. **Reusability:**

- Classes in a package can be reused across different projects or modules by simply importing the package.
5. **Modularity:**

- Packages promote modular programming by dividing the codebase into smaller, manageable units.
6. **Ease of Deployment:**

- Packages simplify the deployment of large projects, as they allow for clear separation of functionality.


**How to Use the `package` Keyword**
1. **Declaring a Package**:

    - The package keyword is used at the beginning of a Java file to specify the package.
    - Syntax:
```java
package packageName;

```
2. **Example**

```java
package com.example.utils;

public class Utility {
    public void display() {
        System.out.println("Utility class in com.example.utils package");
    }
}

```
3. **Importing Packages:**
- To use classes from another package, you can import the package.

- Syntax:
```java
import packageName.ClassName; // Import specific class
import packageName.*;         // Import all classes in the package

```
- Example
```java
import com.example.utils.Utility;

public class Main {
    public static void main(String[] args) {
        Utility util = new Utility();
        util.display();
    }
}

```
4. **Default Package:**

* If no package is specified, the class belongs to the **default package**.
* **Note**: Classes in the default package cannot be imported by classes in other packages, which is why it’s discouraged for large projects.

**Benefits of Using Packages**
* **Organized Structure:**

    - Makes large codebases more manageable.
    - Example: Java's standard library uses packages (`java.util`, `java.io`, etc.).
* **Encapsulation:**

    - Packages can hide implementation details by using access modifiers effectively.
3. **Easier Collaboration:**

    - Teams can work on separate packages without interfering with each other's code.
4. **Scalability:**

    - Allows for the addition of new features without disturbing the existing code structure.

**Real-World Example**\
A banking application might use packages as follows:
```
com.bank.accounts      // Classes like SavingsAccount, CurrentAccount
com.bank.transactions  // Classes like FundTransfer, Payment
com.bank.customers     // Classes like Customer, CustomerProfile

```

### 10. What are the rules for Java identifiers?
In Java, **identifiers** are names given to variables, methods, classes, packages, and other entities. There are specific rules and conventions for naming these identifiers in Java.

**Rules for Java Identifiers:**
1. **Start with a Letter, Underscore, or Dollar Sign:**

* An identifier must begin with a letter (`A-Z` or `a-z`), an underscore (`_`), or a dollar sign (`$`).
* Example: `age`, `_count`, `$total`.

2. **Subsequent Characters:**

* After the first character, an identifier can contain letters (`A-Z`, `a-z`), digits (`0-9`), underscores (`_`), or dollar signs (`$`).
* Example: `firstName`, `totalAmount1`, `sum_$`.

3. **Cannot Be a Java Keyword:**

* Identifiers cannot be any of the reserved Java keywords (such as `int`, `class`, `public`, `static`, etc.).
* Example: `class`, `public`, `new` are invalid identifiers.

4. **Case Sensitivity:**

* Java identifiers are **case-sensitive**, meaning `Variable`, `variable`, and `VARIABLE` are considered different identifiers.
* Example: `total` and `Total` are two distinct identifiers.

5. **No Special Characters Except Underscore and Dollar Sign:**

* Identifiers cannot contain spaces or special characters like `@,` `#,` `%,` `&,` etc.
* Example: `first-name`, `#value` are invalid identifiers.

6. **Length of the Identifier:**

* An identifier can be of any length, but it is recommended to use meaningful, readable names to improve code clarity.

7. **Cannot Start with a Digit:**

* An identifier cannot begin with a digit (`0-9`), although it can contain digits after the first character.
* Example: `1stValue` is an invalid identifier, but `value1` is valid.

8. **Avoid Using Reserved Words (Not Keywords):**

* Java also reserves certain words that are not technically keywords but are still restricted. For example, `true`, `false`, and `null` are literal values and cannot be used as identifiers.
* Example: `true`, `null` are invalid identifiers.

**Examples of Valid and Invalid Identifiers:**\
**Valid Identifiers:**
```java
int totalAmount;         // Starts with a letter, contains letters and digits
String _firstName;       // Starts with an underscore
boolean $isActive;       // Starts with a dollar sign
int MAX_VALUE;           // All uppercase letters (commonly used for constants)

```
**Invalid Identifiers:**
```java
int 123abc;              // Starts with a digit
String class;            // `class` is a keyword
boolean @value;          // Contains an invalid character (@)
int first-name;          // Contains a hyphen (-)

```
**Java Identifier Naming Conventions:**\
Although not strictly required by the language, Java developers follow certain naming conventions for better readability and maintainability of the code:

  *    **Class names**: Use **PascalCase** (e.g., `MyClass`, `EmployeeDetails`).
  *    **Method and variable names**: Use camelCase (e.g., `calculateTotal()`, `firstName`).
  *    **Constant names**: Use **UPPER_SNAKE_CASE** (e.g., `MAX_VALUE`, `PI`).
  *    **Package names**: Typically all lowercase, often with reverse domain name (e.g., `com.mycompany.project`).



### 11. What is the use of the import statement?

The import statement in Java is used to allow access to classes, interfaces, or entire packages from another package, making it easier to use those classes in your program without needing to fully qualify their names each time.


**Uses of the** `import` **Statement**:
1. **Simplify Code:**

* Instead of using fully qualified class names (e.g., `java.util.ArrayList`), you can use shorter class names by importing them (e.g., `ArrayList`).

2. **Access Classes from Other Packages:**

* Java classes are grouped into packages. The `import` statement allows you to access those classes directly.
* Example:

```java
import java.util.Scanner;
Scanner sc = new Scanner(System.in);

```

3. **Improves Readability:**

* Using import makes the code more concise and readable, as it eliminates repetitive package prefixes.

4. **Supports Modular Programming:**

* Enables the reuse of existing libraries or utilities, fostering modular and scalable programming.

**Types of Import Statements:**
1. **Single Type Import:**

* Imports a specific class or interface from a package.
* Syntax:

```java
import packageName.ClassName;

```
* Example
```java
import java.util.ArrayList;
ArrayList<Integer> list = new ArrayList<>();

```

2. **Wildcard Import:**

* Imports all classes and interfaces from a package.
* Syntax

```java
import packageName.*;

```
* Example
```java
import java.util.*;
ArrayList<Integer> list = new ArrayList<>();
HashMap<String, String> map = new HashMap<>();

```
* **Note**: Wildcard imports can lead to namespace conflicts and are generally discouraged in favor of explicit imports.


3. **Static Import:**

* Imports static members (fields and methods) of a class so that they can be accessed directly without class qualification.
* Syntax:

```java
import static packageName.ClassName.staticMember;

```
* Example

```java
import static java.lang.Math.PI;
import static java.lang.Math.sqrt;

double radius = 5;
double area = PI * radius * radius;
double result = sqrt(area);

```

**Key Points About `import`:**
1. **No Need to Import `java.lang`:**

* Classes in the `java.lang` package (e.g., `String`, `Math`, `Object`) are automatically imported.

2. **Fully Qualified Names Can Bypass Import:**

* Instead of using `import`, you can use a class's fully qualified name in the code.
* Example:
```java
java.util.ArrayList<Integer> list = new java.util.ArrayList<>();

```
3. **Static Import for Constants and Utility Methods:**

* Static imports are especially useful for constants and utility methods, making the code cleaner.
* Example
```java
import static java.lang.Math.*;

double value = pow(2, 3); // No need to write Math.pow()

```
4. **Custom Packages:**

* If you define your own packages, you can use the import statement to use classes from those packages in other parts of your project.
* Example:
```java
package mypackage;

public class MyClass {
    public void display() {
        System.out.println("Hello from MyClass");
    }
}

```
```java
import mypackage.MyClass;

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.display();
    }
}

```


### 12. What is a constructor in Java?

A **constructor** in Java is a special method used to initialize objects. It is called automatically when an object is created. Unlike regular methods, constructors do not have a return type (not even `void`) and must have the same name as the class.

**Characteristics of Constructors:**
1. **Same Name as the Class:**

    - The constructor's name must match the class name exactly.
2. **No Return Type:**

   - Constructors do not have a return type, not even void.
3. **Called Automatically:**

    - Constructors are invoked automatically when an object is instantiated.
4. **Overloading Allowed:**

    - Multiple constructors can exist in a class with different parameter lists (constructor overloading).


**Types of Constructors:**
1. **Default Constructor (No-Argument Constructor):**

    - If no constructor is defined explicitly, Java provides a default constructor that initializes the object with default values.

```java
public class Example {
    int number;
    String text;

    // Default constructor
    public Example() {
        number = 0;
        text = "Default";
    }
}

public class Main {
    public static void main(String[] args) {
        Example obj = new Example();
        System.out.println("Number: " + obj.number); // Output: 0
        System.out.println("Text: " + obj.text);    // Output: Default
    }
}

```

2. **Parameterized Constructor:**

    - A constructor that accepts arguments to initialize an object with specific values.

```java
public class Example {
    int number;
    String text;

    // Parameterized constructor
    public Example(int num, String txt) {
        number = num;
        text = txt;
    }
}

public class Main {
    public static void main(String[] args) {
        Example obj = new Example(42, "Hello");
        System.out.println("Number: " + obj.number); // Output: 42
        System.out.println("Text: " + obj.text);    // Output: Hello
    }
}

```
3. **Copy Constructor:**

    - Used to create a new object as a copy of an existing object. Java does not provide a built-in copy constructor, but you can implement one manually.

```java
public class Example {
    int number;
    String text;

    // Parameterized constructor
    public Example(int num, String txt) {
        number = num;
        text = txt;
    }

    // Copy constructor
    public Example(Example obj) {
        this.number = obj.number;
        this.text = obj.text;
    }
}

public class Main {
    public static void main(String[] args) {
        Example obj1 = new Example(42, "Hello");
        Example obj2 = new Example(obj1); // Copy constructor called
        System.out.println("Number: " + obj2.number); // Output: 42
        System.out.println("Text: " + obj2.text);    // Output: Hello
    }
}

```
![img_15.png](img_15.png)

**Best Practices:**
1. **Use Parameterized Constructors for Flexibility:**

    - Parameterized constructors make it easier to create objects with specific values.
2. **Use `this` Keyword:**

    - Use this to differentiate between class fields and constructor parameters if their names are the same.

```java
public class Example {
    int number;

    public Example(int number) {
        this.number = number; // Distinguishes between field and parameter
    }
}

```
3. **Avoid Heavy Logic in Constructors:**

    - Keep constructors simple and avoid including complex logic that could make the code harder to maintain.

4. Use **constructor chaining** (this(...)) to call one constructor from another within the same class to avoid duplicate code.

Example of Constructor Chaining:
```java
public class Employee {
    String name;
    int id;

    // Constructor chaining
    public Employee() {
        this("Default Name", 0); // Calls the parameterized constructor
    }

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    public void display() {
        System.out.println("Name: " + name + ", ID: " + id);
    }

    public static void main(String[] args) {
        Employee emp1 = new Employee();
        Employee emp2 = new Employee("John", 101);

        emp1.display(); // Output: Name: Default Name, ID: 0
        emp2.display(); // Output: Name: John, ID: 101
    }
}

```


**Common Use Case:**\
Constructors are commonly used to enforce object immutability by requiring all essential values to be set at the time of object creation.

```java
public class Person {
    private final String name;
    private final int age;

    // Parameterized constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

```
**Constructor Overloading:**\
Java allows overloading of constructors, which means you can have multiple constructors with different parameter lists.

Example:
```java
public class Person {
    String name;
    int age;

    // Default Constructor
    public Person() {
        this.name = "Default Name";
        this.age = 0;
    }

    // Parameterized Constructor
    public Person(String name) {
        this.name = name;
        this.age = 0;
    }

    // Another Parameterized Constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void display() {
        System.out.println("Name: " + name + ", Age: " + age);
    }

    public static void main(String[] args) {
        Person p1 = new Person();
        Person p2 = new Person("Bob");
        Person p3 = new Person("Charlie", 30);

        p1.display(); // Output: Name: Default Name, Age: 0
        p2.display(); // Output: Name: Bob, Age: 0
        p3.display(); // Output: Name: Charlie, Age: 30
    }
}

```

**Why Use Constructors?**
1. **Object Initialization:**
    - Ensures the object is in a valid state after creation.
2. **Code Simplicity:**
   - Automatically sets up the object during creation, reducing manual initialization.
3. **Overloaded Flexibility:**
   - Allows multiple ways of initializing an object by overloading constructors.

### 13.Can a constructor be static or final?

**1. Static Constructor:**
*    **No, constructors cannot be static in Java.**
*    A constructor is meant to initialize an instance of a class, and it operates on instance-level data.
*    The `static` keyword is used for class-level methods or fields, which are shared among all instances and are not tied to any specific object.
*    Since constructors are inherently tied to the creation of objects (instances), making them static contradicts their purpose.

**Why Not Static?**
- A `static` method can be called without creating an instance of a class, but constructors are specifically designed to create instances. Hence, they cannot be static.

**2. Final Constructor:**
*    **No, constructors cannot be declared as `final` in Java.**
*    The final keyword prevents method overriding. However, constructors are not inherited and cannot be overridden by subclasses. Thus, there is no reason or provision to declare a constructor as `final`.

**Why Not Final?**
* The `final` keyword is applicable only to methods, classes, and variables, and it serves no purpose for constructors because:
    1. Constructors are not inherited.
    2. Constructors are not designed to be overridden.


**What Can Be Done Instead?**
* You can use the `final` keyword for fields or methods to enforce immutability or prevent method overriding.
* Static initialization blocks (`static { ... }`) can be used to initialize class-level static data, but they are not constructors.

**Example: Static Initialization Block**\
If you need something like a "static constructor" for class-level initialization:
```java
public class StaticExample {
    static int staticValue;

    // Static block for initialization
    static {
        staticValue = 100;
        System.out.println("Static block executed.");
    }

    public StaticExample() {
        System.out.println("Constructor executed.");
    }

    public static void main(String[] args) {
        System.out.println("Static value: " + staticValue);
        StaticExample obj = new StaticExample();
    }
}

```
**Output:**
```
Static block executed.
Static value: 100
Constructor executed.

```

### 14. What is the String class in Java?
The `String` class in Java represents a sequence of characters. It is a widely used class in Java, and all string literals (e.g., "`Hello`") are instances of the `String` class. Strings are immutable, meaning once created, their content cannot be changed.

**Key Features of the String Class:**
1. **Immutability:**

    - A String object cannot be modified after it is created. Any modification results in the creation of a new string.

Example:
```java
String str = "Hello";
str = str + " World";
System.out.println(str); // Output: Hello World

```
2. **Stored in String Pool:**

    - String literals are stored in the **String Constant Pool** for memory efficiency. If a string with the same value already exists, the reference to the existing object is returned.
3. **Java’s Built-in Methods:**

    - The `String` class provides many methods for string manipulation, such as concatenation, comparison, length calculation, substring extraction, etc.
4. **Implements `Serializable` and `Comparable`:**

   - Strings can be serialized and compared lexicographically using the `Comparable` interface.

**Creating Strings:**
1. **Using String Literals:**
```java
String str = "Hello";

```
2. Using the `new` Keyword:
```java
String str = new String("Hello");

```
This creates a new object in the heap, even if the same string exists in the pool.

![img_16.png](img_16.png)

**Example: Using the String Class**
```java
public class StringExample {
    public static void main(String[] args) {
        String str1 = "Java";
        String str2 = new String("Java");

        // String methods
        System.out.println("Length: " + str1.length());              // Output: Length: 4
        System.out.println("Char at 2: " + str1.charAt(2));          // Output: Char at 2: v
        System.out.println("Substring: " + str1.substring(1, 3));    // Output: Substring: av
        System.out.println("Equals: " + str1.equals(str2));          // Output: Equals: true
        System.out.println("Contains 'va': " + str1.contains("va")); // Output: Contains 'va': true

        // Immutability demonstration
        String str3 = str1.concat(" Programming");
        System.out.println("Original: " + str1);                     // Output: Original: Java
        System.out.println("New String: " + str3);                  // Output: New String: Java Programming
    }
}

```
**Advantages of String Immutability:**
1. **Security:**

    - Strings used in sensitive operations (e.g., passwords or database connections) cannot be modified.
2. **Thread Safety:**

    - Immutable objects are inherently thread-safe.
3. **String Pool Efficiency:**

    - Reduces memory overhead as duplicate literals point to the same object.

### 15. What is the difference between String, StringBuilder, and StringBuffer?
![img_17.png](img_17.png)

**1. String**
*    **Definition**: Strings are immutable, meaning their value cannot be changed once created.
*    **Usage**: Suitable when the content of the string is not frequently modified.
*    **Examples**:

```java
String str = "Hello";
str = str + " World"; // Creates a new object
System.out.println(str); // Output: Hello World

```
**Advantages:**

* Immutable strings are thread-safe.
* Efficient memory management using String Pool.
**Disadvantages:**

- Poor performance for frequent modifications due to the creation of new objects.

**2. StringBuilder**
*    **Definition**: A mutable class for creating and manipulating strings.
*    **Thread-Safety**: Not thread-safe (not synchronized).
*    **Usage**: Suitable for single-threaded environments where frequent string modifications are needed.
   
**Example:**
```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World"); // Modifies the same object
System.out.println(sb.toString()); // Output: Hello World

```
**Advantages:**\
    - Faster than String and StringBuffer due to no synchronization overhead.\
**Disadvantages:**\
    - Cannot be safely used in multi-threaded environments.

**3. StringBuffer**
*    **Definition**: A thread-safe, mutable class for creating and modifying strings.
*    **Thread-Safety**: Thread-safe due to synchronized methods.
*    **Usage**: Suitable for multi-threaded environments where string modifications are needed.
   
**Example**:
```java
StringBuffer sb = new StringBuffer("Hello");
sb.append(" World"); // Modifies the same object
System.out.println(sb.toString()); // Output: Hello World

```
**Advantages**:\
    - Ensures thread safety in multi-threaded applications.\
**Disadvantages**:\
    - Slower than StringBuilder due to synchronization overhead.


**Performance Comparison**
1. **String:**

    - Inefficient for frequent modifications.
    - Every modification creates a new object.
2. **StringBuilder:**

    - Fastest for single-threaded operations.
    - Avoids object creation for every modification.
3. **StringBuffer:**

    - Slower than StringBuilder due to synchronization but ensures thread safety.

![img_18.png](img_18.png)

**Example: Comparing Usage**
```java
public class StringComparison {
    public static void main(String[] args) {
        // String (Immutable)
        String str = "Java";
        str = str + " Programming";
        System.out.println("String: " + str);

        // StringBuilder (Mutable, not thread-safe)
        StringBuilder sb = new StringBuilder("Java");
        sb.append(" Programming");
        System.out.println("StringBuilder: " + sb);

        // StringBuffer (Mutable, thread-safe)
        StringBuffer sbf = new StringBuffer("Java");
        sbf.append(" Programming");
        System.out.println("StringBuffer: " + sbf);
    }
}

```
**Output:**
```
String: Java Programming
StringBuilder: Java Programming
StringBuffer: Java Programming

```
### 16. What is the difference between == and .equals()?

The difference between `==` and `.equals()` in Java lies in what they compare and how they are implemented. Here's a detailed explanation:

**1. == Operator**
* **Purpose**: Compares memory references (object identity).
* **Usage**: Checks if two references point to the same memory location.
* **Scope**:
  - For **primitives**, compares the actual value.
  - For **objects**, compares the references.
     
**Example:**
```java
String str1 = new String("Hello");
String str2 = new String("Hello");

System.out.println(str1 == str2); // Output: false (different memory locations)

```
- In this case, even though the content of `str1` and `str2` is the same, `==` returns `false` because they are two different objects in memory.

**2.** `.equals()` **Method**
* **Purpose**: Compares content (object equality).
* **Usage**: Checks if two objects are logically "equal."
* **Default Behavior**:
  - In the base `Object class`, `.equals()` is equivalent to `==` unless overridden.
  
- **Override**: Classes like `String`, `Integer`, etc., override `.equals()` to compare values instead of references.

**Example**
```java
String str1 = new String("Hello");
String str2 = new String("Hello");

System.out.println(str1.equals(str2)); // Output: true (content is the same)

```
- Here, `.equals()` returns `true` because the content of `str1` and `str2` is identical.
![img_19.png](img_19.png)

**Example: Comparing Strings**

```java
public class ComparisonExample {
    public static void main(String[] args) {
        String s1 = "Java";
        String s2 = "Java";
        String s3 = new String("Java");

        // Using ==
        System.out.println(s1 == s2); // true (same reference in String Pool)
        System.out.println(s1 == s3); // false (different memory locations)

        // Using .equals()
        System.out.println(s1.equals(s2)); // true (same content)
        System.out.println(s1.equals(s3)); // true (same content)
    }
}

```
**Custom Objects**\
By default, `.equals()` in user-defined classes behaves like `==` unless explicitly overridden.

Example:
```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }
}

public class CustomEqualsExample {
    public static void main(String[] args) {
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");

        System.out.println(p1 == p2);          // false (different objects)
        System.out.println(p1.equals(p2));    // false (default equals is same as ==)
    }
}

```
To compare objects logically:
```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return name.equals(person.name);
    }
}

public class CustomEqualsExample {
    public static void main(String[] args) {
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");

        System.out.println(p1.equals(p2));    // true (logical equality)
    }
}

```
### 17. How does Java handle null values?
Java provides several ways to handle null values effectively. Understanding and managing `null` is crucial to avoid common runtime exceptions like `NullPointerException`. Below are the details:

**1. What is null in Java?**
* **Definition**: `null` is a special literal in Java representing the absence of a value or an uninitialized object reference.
* It can be assigned to any reference type but not to primitives.

**2. Null Handling and Common Scenarios**\
**a. Checking for** `null`
- Before accessing an object or calling its methods, check whether it is null.

**Example:**
```java
String name = null;
if (name != null) {
    System.out.println(name.length());
} else {
    System.out.println("Name is null");
}

```
**b. Avoiding** `NullPointerException`
- A NullPointerException occurs when attempting to access or modify a null object.

**Common Scenarios:**

1. Accessing methods or fields of a `null` object.
2. Using `null` in a collection without checking.
3. Auto-unboxing a `null` value to a primitive.

**Example of Exception:**
```java
String name = null;
System.out.println(name.length()); // Throws NullPointerException

```
**c. Using `Optional` (from Java 8)**
- Purpose: `Optional` is a container object used to represent optional or absent values.
- It provides a more expressive way to handle `null`.

**Example**
```java
import java.util.Optional;

public class OptionalExample {
    public static void main(String[] args) {
        Optional<String> optionalName = Optional.ofNullable(null);
        System.out.println(optionalName.orElse("Default Name")); // Outputs: Default Name
    }
}

```
**d. Default Initialization**
- Local variables must be explicitly initialized; otherwise, they cannot be used.
- Instance and static variables are initialized to null by default if they are references.
Example:
```java
class Example {
    String name; // Defaults to null

    void printName() {
        System.out.println(name); // Safe to access, prints: null
    }
}

```
**e. Using Ternary Operator**
- Simplify null checks with a ternary operator.

**Example:**

```java
String name = null;
String displayName = (name != null) ? name : "Default Name";
System.out.println(displayName); // Outputs: Default Name

```
**3. Best Practices for Handling null**
1. **Initialize Objects Properly:**

   - Always initialize variables with meaningful defaults or valid objects.
2. **Use Optional for Return Values:**

    - For methods that may return null, consider returning Optional instead.

Example:
```java
public Optional<String> getName() {
    return Optional.ofNullable(null);
}

```
3. **Check Parameters for `null` in Methods:**
    - Validate input arguments explicitly to prevent unexpected behavior.

**Example**

```java
public void printLength(String text) {
    if (text == null) {
        throw new IllegalArgumentException("Input cannot be null");
    }
    System.out.println(text.length());
}

```
4. **Leverage Annotations:**

    - Use annotations like `@NonNull` or `@Nullable` (from libraries like Lombok or Checker Framework) to enforce null constraints during compile time.
5. **Use Collections Carefully:**

    - Avoid inserting `null` into collections, as it can lead to unpredictable results in certain cases like sorting.


**4. Null-Safe Techniques**
**a. Null-Safe Navigation (Ternary Alternative)**

Example:
```java
String name = null;
System.out.println(name != null ? name.toUpperCase() : "Default Name");

```
**b. Null-Safe API with Java 8**\
**Stream Example:**
```java
List<String> names = Arrays.asList("Alice", null, "Bob");
names.stream()
     .filter(Objects::nonNull) // Skip null values
     .forEach(System.out::println);

```
**5. How Java Frameworks Handle null**
1. **Spring Framework:**

    - Use `@Nullable` for parameters or return values that can be `null`.
    - Use dependency injection to manage object initialization and avoid `null`.
2. **Hibernate:**

    - Supports null values for optional database fields.
    - Use `@NotNull` to enforce non-null constraints.


**6. Tools for Null Checks**
* **IDE Support**: Modern IDEs like IntelliJ IDEA and Eclipse warn about potential `null` references.
* **Static Analysis Tools**: Tools like FindBugs, SpotBugs, or SonarQube detect possible `null` pointer issues at compile time.


### 18. What is the use of the instanceof operator?
The `instanceof` operator in Java is used to check whether an object is an instance of a specific class or a subclass thereof. It is a binary operator that returns a boolean value (`true` or `false`). This operator helps ensure type safety and avoid runtime exceptions like `ClassCastException`.

**Syntax**
```java
object instanceof ClassName

```
* `object`: The reference to the object being checked.
* `ClassName`: The class or interface to be checked against.

**Key Features**
1. **Returns** `true` **if the object is an instance of the given class or subclass**.
2. **Returns** `false` **if the object is** `null`.
3. Can also be used to check if an object implements a specific interface.

**Examples**\
**1. Basic Usage**
```java
class Animal {}
class Dog extends Animal {}

public class InstanceofExample {
    public static void main(String[] args) {
        Animal animal = new Dog();
        
        System.out.println(animal instanceof Dog);   // true
        System.out.println(animal instanceof Animal); // true
        System.out.println(animal instanceof String); // false
    }
}

```
**2. Preventing `ClassCastException`**
    - The instanceof operator is often used to ensure safe casting.

**Example:**
```java
class Animal {}
class Dog extends Animal {}

public class SafeCastingExample {
    public static void main(String[] args) {
        Animal animal = new Dog();

        if (animal instanceof Dog) {
            Dog dog = (Dog) animal; // Safe downcasting
            System.out.println("Animal is a Dog.");
        }
    }
}

```
**3. Checking for Interface Implementation**
```java
interface Flyable {}
class Bird implements Flyable {}

public class InterfaceCheck {
    public static void main(String[] args) {
        Flyable bird = new Bird();
        
        System.out.println(bird instanceof Flyable); // true
        System.out.println(bird instanceof Bird);    // true
    }
}

```
**Special Cases**
1. **With** `null`
   - The `instanceof` operator always returns `false` for `null`.

**Example**
```java
Dog dog = null;
System.out.println(dog instanceof Dog); // false

```
2. **With Parent-Child Relationships**
   - If a child object is referenced by a parent class, instanceof still detects the actual type.

**Example**
```java
Animal animal = new Dog();
System.out.println(animal instanceof Dog);    // true
System.out.println(animal instanceof Animal); // true

```
3. **With Interfaces**
   - instanceof works seamlessly with interfaces.

**Example**:
```java
interface Movable {}
class Car implements Movable {}

Movable movable = new Car();
System.out.println(movable instanceof Movable); // true
System.out.println(movable instanceof Car);     // true

```
**Common Use Cases**
1. **Type Checking for Polymorphism:**

    - When dealing with polymorphic references, use `instanceof` to determine the actual object type.
2. **Avoiding Runtime Errors:**

    - Prevents `ClassCastException` by ensuring safe type casting.
3. **Dynamic Type Identification:**

    - Helps identify the runtime type of objects for specific operations.
4. **Checking Interface Implementation:**

    - Verify if an object implements a specific interface.


**Limitations and Considerations**
1. **Overuse Can Indicate Poor Design:**
    - Excessive use of instanceof might suggest the need for better design patterns, such as polymorphism or the use of abstract methods.
2. **Compile-Time Type Must Be Compatible:**
   - If the reference type is not related to the class being checked, the code will fail at compile time.
   
Example:
```java
String str = "Hello";
System.out.println(str instanceof Dog); // Compilation Error: Dog is unrelated to String

```
### 19. What is the difference between checked and unchecked exceptions?

In Java, exceptions are classified into two types: **checked exceptions** and **unchecked exceptions**. They differ in how they are handled by the programmer and the compiler.

**1. Checked Exceptions**\
Checked exceptions are exceptions that **must be handled** by the programmer. These exceptions are checked at compile time, meaning the compiler forces the programmer to either catch the exception using a `try-catch` block or declare it in the method signature using the `throws` keyword.

* **Subclass of** `Exception` but not `RuntimeException`.
* Typically represent recoverable conditions and external errors (e.g., file not found, network issues, etc.).

**Examples of Checked Exceptions:**
* `IOException`
* `SQLException`
* `ClassNotFoundException`
* `FileNotFoundException`

**How to handle checked exceptions:**
- Use a `try-catch` block to catch the exception:

```java
try {
    // code that might throw a checked exception
    FileReader file = new FileReader("file.txt");
} catch (IOException e) {
    // handle exception
    e.printStackTrace();
}

```
- Declare the exception in the method signature using `throws`

```java
public void readFile() throws IOException {
    FileReader file = new FileReader("file.txt");
}

```
**2. Unchecked Exceptions**
Unchecked exceptions, also known as **runtime exceptions**, are exceptions that **do not need to be explicitly handled** by the programmer. These exceptions are checked at **runtime** rather than compile time, meaning the compiler does not require the programmer to catch them or declare them in the method signature.

* **Subclass of** `RuntimeException`.
* Typically represent programming errors or logic errors, such as incorrect inputs or violations of invariants.
* These exceptions usually cannot be recovered from within the program, and they indicate issues that should be fixed during development rather than handled at runtime.

**Examples of Unchecked Exceptions:**
* `NullPointerException`
* `ArrayIndexOutOfBoundsException`
* `ArithmeticException`
* `IllegalArgumentException`

**How to handle unchecked exceptions:**
While you don't have to explicitly catch or declare unchecked exceptions, you can still handle them using a `try-catch` block if needed:
```java
try {
    int result = 10 / 0; // ArithmeticException (divide by zero)
} catch (ArithmeticException e) {
    e.printStackTrace();
}

```
![img_20.png](img_20.png)

**When to Use Checked and Unchecked Exceptions:**
* **Checked Exceptions**: Use checked exceptions when the program can recover from the exception or when the exception is caused by external factors, like file access or network issues, where handling it might allow the program to continue operating.

* **Unchecked Exceptions**: Use unchecked exceptions for programming errors that are typically the result of logic mistakes, invalid arguments, or improper state (e.g., `NullPointerException`, `ArithmeticException`). These are often not recoverable and should be fixed in the code rather than handled at runtime.

**Example of Both Types:**\
**Checked Exception Example (IOException):**
```java
public void readFile() throws IOException {
    FileReader file = new FileReader("file.txt");  // Might throw IOException
}

```
You must handle or declare `IOException` using `try-catch` or throws.

**Unchecked Exception Example (NullPointerException):**
```java
public void processData(String data) {
    System.out.println(data.length());  // Might throw NullPointerException if data is null
}

```
You are not required to handle or declare `NullPointerException`, but it’s best to ensure `data` is not `null` to avoid it.

### 20. What is the purpose of the try-catch block?

The **try-catch block** in Java is used for handling exceptions in a controlled manner. It allows you to write code that can potentially throw exceptions (runtime or checked exceptions), while also providing a mechanism to catch and handle those exceptions without crashing the program. This helps to maintain normal program flow even when unexpected situations arise.

**Purpose of the try-catch Block:**
1. **Exception Handling:**

    - The main purpose of a `try-catch` block is to handle exceptions that might occur during the execution of code inside the `try` block. It prevents the application from crashing by catching exceptions and allowing the program to recover from them.
2. **Graceful Degradation:**

    - When an exception occurs, instead of terminating the program, a `try-catch` block can help handle the exception and allow the application to continue executing other tasks or provide a meaningful error message.
3. **Separation of Error Handling:**

    - The `try` block contains the code that might throw an exception, while the `catch` block is used to handle the exception. This separates normal code execution from error handling, making the program more readable and maintainable.
4. **Error Logging:**

    - The `catch` block provides a place where you can log the exception details, making it easier to debug issues by inspecting the exception message and stack trace.

**Syntax of try-catch Block:**

```java
try {
    // Code that may throw an exception
    int result = 10 / 0;  // ArithmeticException (divide by zero)
} catch (ArithmeticException e) {
    // Code to handle the exception
    System.out.println("Exception occurred: " + e.getMessage());
}

```
**How it works:**
1. The code in the `try` block is executed first.
2. If an exception occurs during the execution of the `try` block, the remaining code in the `try` block is skipped, and the control moves to the `catch` block.
3. If the exception type matches the type specified in the `catch` block (or any of its parent types), the code in the `catch` block is executed.
4. After the `catch` block is executed, the program continues with the code after the entire `try-catch `block.


**Example**
```java
public class TryCatchExample {
    public static void main(String[] args) {
        try {
            // Code that may throw an exception
            int[] numbers = {1, 2, 3};
            int result = numbers[5];  // ArrayIndexOutOfBoundsException
        } catch (ArrayIndexOutOfBoundsException e) {
            // Handle exception
            System.out.println("Exception caught: " + e.getMessage());
        }
        
        System.out.println("Program continues after exception.");
    }
}

```
**Output**
```
Exception caught: Index 5 out of bounds for length 3
Program continues after exception.

```
In this example:

* The `try` block attempts to access an array index that doesn't exist, causing an `ArrayIndexOutOfBoundsException`.
* The `catch` block catches the exception and prints an error message.
* The program continues execution after the `catch` block, demonstrating graceful error handling.


**Benefits of Using try-catch:**
* **Prevent Application Crashes:** By handling exceptions, the application doesn't terminate abruptly when an error occurs.
* **Error Reporting:** You can catch specific exceptions and report them, either through logging or user-friendly messages.
* **Clean Code:** Separating error handling from normal logic makes the code cleaner and easier to maintain.
* **Flexible Error Handling:** Multiple `catch` blocks can be used to handle different types of exceptions in different ways.

**Important Points:**
- **Multiple catch blocks:** A try block can have multiple `catch` blocks to handle different types of exceptions.

```java
try {
    // code
} catch (IOException e) {
    // Handle IOException
} catch (SQLException e) {
    // Handle SQLException
}

```
- **Catch-all Exception:** A generic `Exception` can be caught to handle any exception not already handled.
```java
try {
    // code
} catch (Exception e) {
    // Handle all exceptions
}

```

- Finally block: Optionally, a `finally` block can be used to execute code after the `try-catch` block, regardless of whether an exception occurred or not. This is useful for cleanup operations (e.g., closing file streams or database connections).

```java
try {
    // code
} catch (Exception e) {
    // handle exception
} finally {
    // cleanup code, always executed
}

```

### 21. Explain abstraction with an example.

Abstraction is one of the core principles of Object-Oriented Programming (OOP). It is the concept of hiding the implementation details and showing only the essential features of an object. Abstraction allows a user to interact with an object or class through a simplified interface, without needing to understand the complexities behind it.

In Java, **abstraction** can be achieved using:

1. Abstract classes
2. Interfaces

By abstracting out complex implementation details, we can focus on what the object does rather than how it does it.

**Key Features of Abstraction:**
1. **Hides Complexity:** Only essential features are exposed, while the internal workings are hidden.
2. **Provides a Simple Interface:** A simplified way to interact with an object.
3. **Achieved with Abstract Classes or Interfaces:** Abstract classes can have both abstract methods (methods without a body) and concrete methods (methods with a body). Interfaces provide a contract that any implementing class must follow.

**Example 1: Abstraction using Abstract Class**\
Consider a scenario where we want to model a Vehicle. A vehicle has some common properties like `speed`, `color`, etc., but how it moves (e.g., `drive()`) can vary between different types of vehicles (e.g., car, bike).

In this example, we will use an abstract class to provide a common template for all vehicles, leaving the specifics of how the vehicle moves to be defined by the concrete subclasses.

```java
// Abstract class
abstract class Vehicle {
    // Common properties
    String color;
    int speed;

    // Concrete method
    public void start() {
        System.out.println("Vehicle started.");
    }

    // Abstract method (does not have implementation)
    public abstract void move();  // Different vehicles will implement this method in their way
}

// Concrete class 1
class Car extends Vehicle {
    public Car(String color, int speed) {
        this.color = color;
        this.speed = speed;
    }

    // Implementing the abstract method
    public void move() {
        System.out.println("Car is driving at speed " + speed + " km/h");
    }
}

// Concrete class 2
class Bike extends Vehicle {
    public Bike(String color, int speed) {
        this.color = color;
        this.speed = speed;
    }

    // Implementing the abstract method
    public void move() {
        System.out.println("Bike is moving at speed " + speed + " km/h");
    }
}

public class AbstractionExample {
    public static void main(String[] args) {
        // Create instances of Car and Bike
        Vehicle car = new Car("Red", 120);
        Vehicle bike = new Bike("Black", 80);

        // Start the vehicles
        car.start();
        bike.start();

        // Move the vehicles (different implementations)
        car.move();  // "Car is driving at speed 120 km/h"
        bike.move(); // "Bike is moving at speed 80 km/h"
    }
}

```
**Explanation:**
* **Abstract Class** `Vehicle`: This class has an abstract method `move()` that does not have an implementation. The concrete classes Car and `Bike` provide their specific implementations of the `move()` method.
* **Concrete Classes** `Car` **and** `Bike`: These classes inherit from `Vehicle` and provide implementations for the abstract `move()` method.
* `start()` method: This is a concrete method in the `Vehicle` class, which all vehicles can use without modification.

**Output:**
```
Vehicle started.
Vehicle started.
Car is driving at speed 120 km/h
Bike is moving at speed 80 km/h

```

**Example 2: Abstraction using Interfaces**\
An interface in Java defines a contract that implementing classes must follow. It can have only abstract methods (in earlier versions of Java), but with Java 8, interfaces can also have default and static methods with implementations.

In this example, we’ll model **Shape** objects (like a `Circle` and a `Rectangle`).
```java
// Interface
interface Shape {
    // Abstract method
    void draw();

    // Default method (from Java 8 onwards)
    default void color() {
        System.out.println("Coloring the shape...");
    }
}

// Concrete class 1
class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing a Circle");
    }
}

// Concrete class 2
class Rectangle implements Shape {
    public void draw() {
        System.out.println("Drawing a Rectangle");
    }
}

public class AbstractionExample {
    public static void main(String[] args) {
        Shape circle = new Circle();
        Shape rectangle = new Rectangle();

        circle.draw();     // Drawing a Circle
        circle.color();    // Coloring the shape...
        
        rectangle.draw();  // Drawing a Rectangle
        rectangle.color(); // Coloring the shape...
    }
}

```
**Explanation:**
* **Interface `Shape`:** This defines the abstract method `draw() `and a default method `color()`. All classes implementing `Shape` must provide their own implementation of `draw()`, but they can inherit the default` color()` method.
* **Concrete Classes** `Circle` **and** `Rectangle`: These classes implement the `Shape` interface and provide their specific implementations of the `draw()` method.

**Output**
```
Drawing a Circle
Coloring the shape...
Drawing a Rectangle
Coloring the shape...
```

**Key Differences Between Abstract Class and Interface for Abstraction:**
1. **Abstract Class:**

   1. Can have both abstract and concrete methods.
   2. Can have instance variables.
   3. A class can extend only one abstract class (since Java supports single inheritance).
   4. Abstract classes are used when there is a "is-a" relationship.

2. **Interface:**

   1. Can only have abstract methods (until Java 8, but now it can have default and static methods).
   2. Cannot have instance variables, only constants (static final variables).
   3. A class can implement multiple interfaces (supports multiple inheritance).
   4. Interfaces are used when a class needs to follow a certain contract, but doesn't necessarily have an "is-a" relationship.

### 22. Explain encapsulation with an example.

**Encapsulation** is one of the fundamental principles of Object-Oriented Programming (OOP). It is the process of bundling the data (variables) and methods (functions) that operate on that data into a single unit, typically a class. Encapsulation also involves restricting direct access to some components of an object to maintain control over its data and protect it from unintended interference.

**Key Features of Encapsulation:**
1. **Data Hiding**: The internal details of an object (its state) are hidden from the outside world. Only the relevant information is exposed through public methods.
2. **Controlled Access**: Access to the data is provided using getter and setter methods.
3. **Improved Security**: It helps prevent unauthorized access or accidental modification of data.

**Benefits of Encapsulation:**
* Improves **code maintainability** and **readability**.
* Protects the integrity of the object's state by enforcing rules on how data is accessed and modified.
* Promotes modularization by allowing you to change the internal implementation of a class without affecting the external code.

**Example: Encapsulation in a Class**\
Let’s consider a simple example of a **Bank Account**. A bank account has private data such as `accountNumber`, `balance`, etc. Users can access and update these fields only through controlled methods.

```java
class BankAccount {
    // Private fields (data hiding)
    private String accountNumber;
    private double balance;

    // Constructor to initialize account
    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        if (initialBalance >= 0) {
            this.balance = initialBalance;
        } else {
            System.out.println("Initial balance cannot be negative.");
            this.balance = 0;
        }
    }

    // Getter for account number (read-only field)
    public String getAccountNumber() {
        return accountNumber;
    }

    // Getter for balance
    public double getBalance() {
        return balance;
    }

    // Method to deposit money (controlled access)
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposited: " + amount);
        } else {
            System.out.println("Deposit amount must be positive.");
        }
    }

    // Method to withdraw money (controlled access)
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Withdrew: " + amount);
        } else if (amount > balance) {
            System.out.println("Insufficient balance.");
        } else {
            System.out.println("Withdrawal amount must be positive.");
        }
    }
}

public class EncapsulationExample {
    public static void main(String[] args) {
        // Create a BankAccount object
        BankAccount account = new BankAccount("1234567890", 5000);

        // Access account details using getter methods
        System.out.println("Account Number: " + account.getAccountNumber());
        System.out.println("Balance: " + account.getBalance());

        // Deposit money
        account.deposit(1000);
        System.out.println("Balance after deposit: " + account.getBalance());

        // Withdraw money
        account.withdraw(2000);
        System.out.println("Balance after withdrawal: " + account.getBalance());

        // Attempt an invalid operation
        account.withdraw(10000); // Insufficient balance
    }
}

```
**Explanation:**
1. **Private Fields:**
    - The fields `accountNumber` and `balance` are declared `private`. This means they cannot be accessed directly from outside the class.

2. **Public Methods:**
   - Methods like `getBalance()`, `deposit()`, and `withdraw()` are public and allow controlled access to the private fields.
   - These methods validate input before performing any operation, ensuring the object's state remains consistent.

3. **Data Hiding:**
   - Direct access to `balance` is restricted. You can only modify it using controlled methods that implement business rules (e.g., ensuring deposits are positive and withdrawals do not exceed the balance).

**Output:**
```yaml
Account Number: 1234567890
Balance: 5000.0
Deposited: 1000.0
Balance after deposit: 6000.0
Withdrew: 2000.0
Balance after withdrawal: 4000.0
Insufficient balance.
```

**Advantages of Encapsulation:**
1. **Improved Security**: Private data can only be accessed through authorized methods.
2. **Flexibility**: Internal implementation can change without affecting external code.
3. **Code Reusability**: Methods encapsulate behavior, making the code modular and reusable.

Encapsulation ensures that objects maintain control over their state while providing a well-defined interface for interaction.

### 23. Explain inheritance with an example.
**Inheritance** is one of the fundamental concepts of Object-Oriented Programming (OOP) in Java. It allows a class (child or subclass) to inherit the properties (fields) and behaviors (methods) of another class (parent or superclass).

This mechanism promotes **code reuse** and establishes a relationship between classes, enabling hierarchical classifications.

**Key Features of Inheritance:**
1. **Code Reusability**: Subclasses can reuse code from their parent class, reducing redundancy.
2. **Method Overriding**: Subclasses can provide a specific implementation of a method that is already defined in the parent class.
3. **Polymorphism**: Inheritance is a foundation for achieving polymorphism in Java.

**Syntax:**\
To create a subclass, use the `extends` keyword:
```java
class Parent {
    // Parent class members
}

class Child extends Parent {
    // Child class members
}

```
**Example: Inheritance in Action**\
Let’s consider a real-world example of **Vehicle** and its subclasses **Car** and **Bike**.
```java
// Parent class
class Vehicle {
    // Common properties of all vehicles
    private String brand;
    private int speed;

    // Constructor
    public Vehicle(String brand, int speed) {
        this.brand = brand;
        this.speed = speed;
    }

    // Method to display vehicle information
    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Speed: " + speed + " km/h");
    }

    // Method to simulate starting the vehicle
    public void start() {
        System.out.println(brand + " is starting...");
    }
}

// Child class - Car
class Car extends Vehicle {
    private int numberOfDoors;

    public Car(String brand, int speed, int numberOfDoors) {
        super(brand, speed); // Call the parent class constructor
        this.numberOfDoors = numberOfDoors;
    }

    // Additional behavior specific to Car
    public void openTrunk() {
        System.out.println("Opening the trunk...");
    }

    @Override
    public void displayInfo() {
        super.displayInfo(); // Call the parent class method
        System.out.println("Number of doors: " + numberOfDoors);
    }
}

// Child class - Bike
class Bike extends Vehicle {
    private boolean hasCarrier;

    public Bike(String brand, int speed, boolean hasCarrier) {
        super(brand, speed);
        this.hasCarrier = hasCarrier;
    }

    // Additional behavior specific to Bike
    public void doWheelie() {
        System.out.println("Doing a wheelie...");
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Has carrier: " + hasCarrier);
    }
}

// Main class
public class InheritanceExample {
    public static void main(String[] args) {
        // Create objects of Car and Bike
        Car car = new Car("Toyota", 180, 4);
        Bike bike = new Bike("Yamaha", 120, true);

        // Display information and behaviors
        System.out.println("Car Details:");
        car.displayInfo();
        car.start();
        car.openTrunk();

        System.out.println("\nBike Details:");
        bike.displayInfo();
        bike.start();
        bike.doWheelie();
    }
}

```
**Explanation:**
1. **Vehicle Class:**

    - It is the parent class, containing properties (`brand` and `speed`) and behaviors (`displayInfo()` and `start()`) common to all vehicles.

2. **Car and Bike Classes:**

    - They are child classes that extend `Vehicle`.
    - They add specific properties and methods, like `openTrunk()` for Car and `doWheelie()` for `Bike`.

3. **Method Overriding:**

    - Both `Car` and `Bike` override the `displayInfo() `method to include their unique properties while retaining common details from the parent class.

4. **super Keyword:**

    - Used to call the parent class constructor or methods.

**Output:**
```yaml
Car Details:
Brand: Toyota, Speed: 180 km/h
Number of doors: 4
Toyota is starting...
Opening the trunk...

Bike Details:
Brand: Yamaha, Speed: 120 km/h
Has carrier: true
Yamaha is starting...
Doing a wheelie...
```
**Advantages of Inheritance:**
1. **Reusability**: Common code resides in the parent class, avoiding duplication in subclasses.
2. **Extensibility**: New functionalities can be added in subclasses without altering existing code.
3. **Polymorphism**: Inheritance enables method overriding, which is a key feature of polymorphism.

**When Not to Use Inheritance:**
1. Avoid using inheritance when classes have weak or no logical relationships. Instead, prefer **composition**.
2. Be cautious about tightly coupling the child class to the parent class, which may reduce flexibility.



### 24. Explain polymorphism with an example.

**Polymorphism** means "many forms." In Java, it allows objects to be treated as instances of their parent class while still executing their specific behaviors. It is a key feature of Object-Oriented Programming (OOP) that enables code flexibility and reusability.

**Types of Polymorphism in Java:**
1. **Compile-Time Polymorphism (Method Overloading):**

    - Achieved by defining multiple methods with the same name but different parameter lists in the same class.
    - Resolved during compile time.

2. **Run-Time Polymorphism (Method Overriding):**

    - Achieved when a subclass provides a specific implementation of a method defined in its parent class.
    - Resolved during runtime using **dynamic method dispatch**.

**Example of Compile-Time Polymorphism (Method Overloading):**
```java
class Calculator {
    // Method to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Method to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Method to add two double values
    public double add(double a, double b) {
        return a + b;
    }
}

public class CompileTimePolymorphismExample {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        // Call different versions of the add method
        System.out.println("Sum of two integers: " + calc.add(10, 20));
        System.out.println("Sum of three integers: " + calc.add(10, 20, 30));
        System.out.println("Sum of two doubles: " + calc.add(10.5, 20.3));
    }
}

```
**Output**
```
Sum of two integers: 30
Sum of three integers: 60
Sum of two doubles: 30.8

```
**Example of Run-Time Polymorphism (Method Overriding):**
```java
// Parent class
class Animal {
    // Method to make a sound
    public void sound() {
        System.out.println("Animals make sound");
    }
}

// Child class - Dog
class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

// Child class - Cat
class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

public class RunTimePolymorphismExample {
    public static void main(String[] args) {
        // Parent class reference pointing to child class objects
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();

        // Call the overridden methods
        animal1.sound(); // Calls Dog's sound method
        animal2.sound(); // Calls Cat's sound method
    }
}

```
**Output**

```
Dog barks
Cat meows

```
![img_21.png](img_21.png)

**Advantages of Polymorphism:**
1. **Code Reusability**: Reuse methods in different forms, avoiding redundancy.
2. **Flexibility**: Write code in terms of the parent class and achieve specific behaviors at runtime.
3. **Extensibility**: Add new functionality in subclasses without affecting existing code.


**Real-World Analogy:**
Imagine a **remote control** (parent class) that operates various devices like a **TV** or **Air Conditioner** (subclasses). The button actions (methods) remain the same (like turning on), but the actual behavior (displaying video vs. cooling the air) varies depending on the device.

This is **polymorphism** in action: the same action (calling a method) performs different tasks depending on the object.

### 25. What is the difference between an abstract class and an interface?

Both **abstract** classes and **interfaces** are used to achieve abstraction in Java. However, they serve different purposes and have distinct characteristics.

**Abstract Class**
An **abstract class** is a class that can have both **abstract methods** (without implementation) and **concrete methods** (with implementation). It is meant to be inherited by subclasses to provide specific implementations of its abstract methods.

**Key Features:**
1. Can have both **abstract** and **non-abstract** methods.
2. Supports fields (with or without modifiers) and can have state (variables).
3. Can have constructors.
4. Supports all types of access modifiers (`public`, `protected`, `private`, etc.) for its methods and fields.
5. Allows inheritance using the `extends` keyword (single inheritance).

**Example**:
```java
abstract class Animal {
    // Abstract method (no implementation)
    abstract void sound();

    // Concrete method (has implementation)
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

public class AbstractClassExample {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.sound(); // Dog barks
        myDog.eat();   // This animal eats food.
    }
}

```
**Interface**
An **interface** is a completely abstract class that defines a contract (set of methods) that a class must implement. It cannot have any concrete methods until Java 8 introduced default and static methods.

**Key Features:**
1. **By default, all methods are** `abstract` (until Java 8; default and static methods are now allowed).
2. **Fields are implicitly** `public`, `static`, and `final`.
3. A class can implement multiple interfaces (multiple inheritance).
4. Methods are implicitly `public` and cannot have access modifiers other than `public`.

**Example**:
```java
interface Animal {
    // Abstract method
    void sound();

    // Default method (introduced in Java 8)
    default void eat() {
        System.out.println("This animal eats food.");
    }
}

class Cat implements Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        Animal myCat = new Cat();
        myCat.sound(); // Cat meows
        myCat.eat();   // This animal eats food.
    }
}

```
![img_22.png](img_22.png)

**When to Use:**
- **Use** abstract classes **when:**
    - You want to share code (concrete methods) between related classes.
    - You need constructors or non-static fields.
- **Use** interfaces **when:**
    - You want to define a contract for unrelated classes to implement.
    - You need to achieve multiple inheritance.

**Example Combining Both:**
```java
abstract class Vehicle {
    abstract void move();

    void fuel() {
        System.out.println("Vehicles need fuel.");
    }
}

interface Electric {
    void chargeBattery();

    default void ecoMode() {
        System.out.println("Electric vehicle in eco mode.");
    }
}

class Tesla extends Vehicle implements Electric {
    @Override
    void move() {
        System.out.println("Tesla moves silently.");
    }

    @Override
    public void chargeBattery() {
        System.out.println("Tesla is charging.");
    }
}

public class CombinedExample {
    public static void main(String[] args) {
        Tesla myTesla = new Tesla();
        myTesla.move();
        myTesla.fuel();
        myTesla.chargeBattery();
        myTesla.ecoMode();
    }
}

```
**Output**

```
Tesla moves silently.
Vehicles need fuel.
Tesla is charging.
Electric vehicle in eco mode.

```

### 26. Can an abstract class have a constructor?

Yes, an **abstract class** can have a constructor in Java.

**Purpose of a Constructor in an Abstract Class**\
Although you cannot instantiate an abstract class directly, its constructor is called when a subclass is instantiated. The constructor is typically used to initialize fields or perform setup tasks that are shared across subclasses.

**Example**
```java
abstract class Vehicle {
    String type;

    // Constructor for the abstract class
    Vehicle(String type) {
        this.type = type;
        System.out.println("Vehicle constructor called: " + type);
    }

    // Abstract method
    abstract void move();
}

class Car extends Vehicle {
    Car(String type) {
        super(type); // Calls the abstract class constructor
    }

    @Override
    void move() {
        System.out.println("Car moves on roads.");
    }
}

public class AbstractClassConstructorExample {
    public static void main(String[] args) {
        Vehicle myCar = new Car("Four-Wheeler");
        myCar.move();
    }
}

```
**Output**
```
Vehicle constructor called: Four-Wheeler
Car moves on roads.

```
**Key Points**
1. **Abstract Class Constructor Invocation:**

    - The constructor of an abstract class is invoked when a subclass object is created using the super keyword.

2. **Use Cases:**

    - Initialize fields common to all subclasses.
    - Set up resources or configurations needed for the hierarchy.

3. **Cannot Instantiate Directly:**

    - While an abstract class can have a constructor, you cannot create an instance of an abstract class directly.

4. **Mandatory Constructor Call:**

    - If the abstract class has a parameterized constructor, its subclasses must call it explicitly using super().

**Why Use a Constructor in an Abstract Class?**
* To ensure consistent initialization logic for all subclasses.
* To enforce specific initialization steps that subclasses might need.

### 27. What are default methods in interfaces?

**Default methods** in interfaces were introduced in **Java 8** to allow interfaces to have methods with implementations. This feature bridges the gap between interfaces and abstract classes by enabling interfaces to provide some default behavior without breaking existing code.

**Key Features**
1. **Defined with the `default` keyword:**

    - A default method is declared using the `default` keyword in an interface.
    - It must have a method body.
2. **Backward Compatibility:**

    - It enables adding new methods to an interface without requiring all implementing classes to modify their code.
3. **Can Be Overridden:**

    - Implementing classes can override default methods to provide their own implementation.
4. **Multiple Inheritance:**

    - If a class implements multiple interfaces with conflicting default methods, the class must explicitly override the method.

**Syntax**
```java
public interface MyInterface {
    default void myDefaultMethod() {
        System.out.println("Default implementation");
    }
}

```
**Example**
```java
interface Vehicle {
    void move(); // Abstract method

    default void fuel() {
        System.out.println("Vehicles need fuel.");
    }
}

class Car implements Vehicle {
    @Override
    public void move() {
        System.out.println("Car moves on roads.");
    }

    // Optionally, override the default method
    @Override
    public void fuel() {
        System.out.println("Car runs on petrol or diesel.");
    }
}

class Bicycle implements Vehicle {
    @Override
    public void move() {
        System.out.println("Bicycle moves using pedals.");
    }
}

public class DefaultMethodExample {
    public static void main(String[] args) {
        Vehicle car = new Car();
        car.move();  // Car moves on roads.
        car.fuel();  // Car runs on petrol or diesel.

        Vehicle bicycle = new Bicycle();
        bicycle.move(); // Bicycle moves using pedals.
        bicycle.fuel(); // Vehicles need fuel.
    }
}

```
**Output**
```
Car moves on roads.
Car runs on petrol or diesel.
Bicycle moves using pedals.
Vehicles need fuel.

```
**Multiple Inheritance Conflict**
If a class implements multiple interfaces with the same default method, the class must override the method to resolve the conflict.

**Example**:
```java
interface A {
    default void show() {
        System.out.println("Default method in A");
    }
}

interface B {
    default void show() {
        System.out.println("Default method in B");
    }
}

class C implements A, B {
    @Override
    public void show() {
        System.out.println("Resolving conflict by overriding in C");
    }
}

public class MultipleInheritanceExample {
    public static void main(String[] args) {
        C obj = new C();
        obj.show();
    }
}

```
**Output**
```
Resolving conflict by overriding in C
```

**Advantages of Default Methods**
1. **Backward Compatibility:**

    - Allows evolving interfaces without breaking existing code.
2. **Multiple Inheritance:**

    - Provides behavior sharing without the need for abstract classes.
3. **Simplifies Code:**
    - Reduces boilerplate by providing reusable default implementations.

**Key Points to Remember**
1. Default methods cannot override methods from `java.lang.Object` (like `toString()` or `equals()`).
2. They are not abstract but can be overridden by implementing classes.
3. If a class implements an interface and provides its own implementation for a default method, the class's method is used.

### 28. Can an interface extend another interface?

Yes, **an interface can extend another interface** in Java. This is how you can create hierarchical relationships among interfaces, enabling one interface to inherit the methods of another.

**Key Points**
1. **Inheritance in Interfaces:**

    - An interface can inherit another interface using the extends keyword.
    - Unlike classes, interfaces can extend multiple interfaces.
2. **All Methods Are Inherited:**

    - The child interface inherits all methods (abstract and default) from the parent interface.
    - The child interface can also declare additional methods.
3. **No Method Implementation:**

    - The child interface cannot provide method implementations (unless using default methods).
4. **Classes Implementing Child Interfaces:**

    - A class implementing a child interface must implement all methods from both the child and parent interfaces.

**Key Takeaways**
1. Interfaces can extend other interfaces (single or multiple) using the `extends` keyword.
2. A class implementing the child interface must implement all methods from the entire interface hierarchy.
3. This feature allows better abstraction, modularity, and flexibility in design.


### 29. What is multiple inheritance in Java?
**Multiple inheritance** refers to a feature where a class can inherit properties and behavior (methods) from more than one parent class or interface. Java supports multiple inheritance with **interfaces** but **does not allow it with classes** to avoid ambiguity problems, such as the **diamond problem**.

**Multiple Inheritance with Classes**
Java **does not support multiple inheritance** with classes directly. This decision was made to prevent conflicts and ambiguities when multiple parent classes define methods or fields with the same name. This issue is commonly referred to as the **diamond problem**.

**Example: Diamond Problem in Classes**
```java
class A {
    void show() {
        System.out.println("Class A");
    }
}

class B {
    void show() {
        System.out.println("Class B");
    }
}

// Error: Java does not support multiple inheritance
class C extends A, B {
    // Ambiguity: Which `show` method should be inherited?
}

```
**How Java Handles Multiple Inheritance**\
**With Interfaces**\
Java supports multiple inheritance with **interfaces** because interfaces only declare method signatures (no implementation in classic interfaces). Since Java 8, interfaces can also include default and static methods, but ambiguities can still be resolved explicitly.

**Example: Multiple Inheritance with Interfaces**
```java
interface InterfaceA {
    default void display() {
        System.out.println("Display from InterfaceA");
    }
}

interface InterfaceB {
    default void display() {
        System.out.println("Display from InterfaceB");
    }
}

class MyClass implements InterfaceA, InterfaceB {
    @Override
    public void display() {
        // Resolving ambiguity
        InterfaceA.super.display();  // Calling InterfaceA's method
        InterfaceB.super.display();  // Calling InterfaceB's method
    }
}

public class MultipleInheritanceExample {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.display();
    }
}

```
**Output**
```
Display from InterfaceA
Display from InterfaceB

```

**Why Java Does Not Support Multiple Inheritance with Classes**
1. **Diamond Problem:**
    - If a class inherits from two parent classes with methods of the same signature, it creates ambiguity about which method to use.
2. **Complexity:**
    - Resolving conflicts in the method and field inheritance can make the language complex and error-prone.
3. **Better Alternatives:**
   - Composition and interfaces provide safer and more manageable ways to achieve the same functionality.

**Multiple Inheritance Alternatives in Java**\
**1. Composition**\
   Instead of extending multiple classes, a class can **contain objects** of other classes and reuse their functionality.

```java
class A {
    void displayA() {
        System.out.println("Display from A");
    }
}

class B {
    void displayB() {
        System.out.println("Display from B");
    }
}

class C {
    A a = new A();
    B b = new B();

    void show() {
        a.displayA();
        b.displayB();
    }
}

public class CompositionExample {
    public static void main(String[] args) {
        C obj = new C();
        obj.show();
    }
}

```
**Output**
```
Display from A
Display from B

```
**2. Using Interfaces**\
   Interfaces allow multiple inheritance and provide flexibility for achieving abstraction and polymorphism.

**Example**
```java
interface Animal {
    void eat();
}

interface Bird {
    void fly();
}

class Bat implements Animal, Bird {
    @Override
    public void eat() {
        System.out.println("Bat eats insects.");
    }

    @Override
    public void fly() {
        System.out.println("Bat can fly.");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        Bat bat = new Bat();
        bat.eat();
        bat.fly();
    }
}

```
**Output**
```
Bat eats insects.
Bat can fly.

```

### 30. What is the purpose of the Object class?

The `Object` class is the root of the class hierarchy in Java. Every class in Java is either a direct or indirect subclass of the `Object` class. It provides a set of methods that are common to all objects in Java, which makes it a fundamental building block of the Java programming language.

**Key Purposes of the Object Class**
1. **Inheritance:**

    - All classes in Java implicitly inherit from the `Object` class, either directly or indirectly.
    - This ensures that every Java object has a standard set of behaviors.
2. **Common Methods:**

    - The `Object` class provides essential methods that all Java objects can use or override to define their own behavior.
    - These methods include `toString()`, `equals()`, `hashCode()`, `clone()`, and others.
3. **Polymorphism:**

    - Since the `Object` class is the root of the hierarchy, a reference of type `Object` can hold a reference to any Java object. This is useful for generic programming.
4. **Synchronization:**

    - Methods like `wait()`, `notify()`, and `notifyAll()` are defined in the `Object` class to facilitate thread synchronization, as every Java object can be used as a monitor for synchronization.

![img_23.png](img_23.png)


**Examples of Object Class Methods**
1. `toString()`\
   The default implementation returns the class name followed by the hash code. It can be overridden for custom behavior.
```java
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

public class ToStringExample {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);
        System.out.println(person); // Calls toString() implicitly
    }
}

```
2. `equals()`

```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return name.equals(person.name);
    }
}

public class EqualsExample {
    public static void main(String[] args) {
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");
        System.out.println(p1.equals(p2)); // true
    }
}

```
3. `hashCode()`\
   Often overridden along with `equals()` to ensure consistent behavior when objects are used in hash-based collections.
```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }
}

public class HashCodeExample {
    public static void main(String[] args) {
        Person person = new Person("Alice");
        System.out.println(person.hashCode()); // Prints hash code based on name
    }
}

```
**Importance in Java**
* The `Object` class methods are the backbone of Java's object-oriented capabilities, enabling consistent behavior across all objects.
* Overriding these methods (like `equals`, `hashCode`, `toString`) is common practice to define specific object behaviors for use cases like comparison, debugging, and storage in collections.

By providing these fundamental methods, the `Object` class ensures uniformity and simplifies the design of the Java language.


### 31. What is the difference between hashCode() and equals()?

The `hashCode()` and `equals()` methods are two fundamental methods in Java's `Object` class. They play a crucial role in determining object equality and how objects are managed in collections like `HashMap`, `HashSet`, and `Hashtable`

![img_24.png](img_24.png)

![img_25.png](img_25.png)

**Contract Between** `equals()` **and** `hashCode()`
1. If two objects are equal (`equals()` returns `true`), they must have the same hash code.
2. If two objects have the same hash code, they might not be equal (`equals()` can return `false`).

Failure to maintain this contract can lead to unexpected behavior in hash-based collections like `HashMap` or `HashSet`.

**Examples**\
**Default Behavior**

```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }
}

public class DefaultExample {
    public static void main(String[] args) {
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");

        System.out.println(p1.equals(p2)); // false (default behavior compares references)
        System.out.println(p1.hashCode() == p2.hashCode()); // false (default hash codes differ)
    }
}

```
Overriding `equals()` and `hashCode()`
```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return name.equals(person.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }
}

public class CustomExample {
    public static void main(String[] args) {
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");

        System.out.println(p1.equals(p2)); // true (custom equality based on name)
        System.out.println(p1.hashCode() == p2.hashCode()); // true (consistent hash codes)
    }
}

```

**Hash-Based Collections**\
If `equals()` and` hashCode()` are not implemented correctly, hash-based collections like `HashSet` and `HashMap` may not behave as expected.

**Example Without Proper Overrides**
```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }
}

public class CollectionExample {
    public static void main(String[] args) {
        HashSet<Person> set = new HashSet<>();
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");

        set.add(p1);
        set.add(p2);

        System.out.println(set.size()); // Output: 2 (Objects are treated as different)
    }
}

```
**Example With Proper Overrides**
```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return name.equals(person.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }
}

public class CollectionExample {
    public static void main(String[] args) {
        HashSet<Person> set = new HashSet<>();
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");

        set.add(p1);
        set.add(p2);

        System.out.println(set.size()); // Output: 1 (Objects are treated as equal)
    }
}

```
### 32. Can we override static methods in Java?

No, **static methods cannot be overridden** in Java. However, they can be redeclared (hidden) in a subclass. This is because static methods belong to the class and not to any specific instance, and method overriding in Java applies only to instance methods.

**Why Can't Static Methods Be Overridden?**
1. **Binding at Compile-Time (Static Binding):** Static methods are resolved during compile-time using the reference type, not the actual object. Overriding involves runtime polymorphism (dynamic binding), which is not applicable to static methods.
2. **Class-Level Association:** Since static methods belong to the class, they are not tied to a specific instance. Overriding requires an instance context to determine the correct method to invoke.

**What Happens When You Declare a Static Method with the Same Name in a Subclass?**\
This is known as **method hiding**, not overriding. The static method in the subclass hides the static method in the superclass, and which method gets called depends on the type of the reference at compile-time.

**Example of Method Hiding**
```java
class Parent {
    static void display() {
        System.out.println("Static method in Parent");
    }
}

class Child extends Parent {
    static void display() {
        System.out.println("Static method in Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj1 = new Parent();
        Parent obj2 = new Child();

        obj1.display(); // Output: Static method in Parent
        obj2.display(); // Output: Static method in Parent (method hiding)
    }
}

```
In the above example:

* `obj1.display()` calls` Parent`'s `display()` method because the reference type is `Parent`.
* `obj2.display()` also calls `Parent`'s `display()` method because `static` methods are resolved based on reference type, not the actual object.

![img_26.png](img_26.png)


**Key Points**
1. Static methods are not overridden; they are hidden.
2. To use runtime polymorphism, you must use instance methods.
3. Always use static methods when the behavior is tied to the class and does not require object state.

### 33. What is method hiding?
Method hiding occurs when a **static method** in a subclass has the **same name** and **method** **signature** as a static method in its superclass. Unlike instance methods (which support overriding), static methods belong to the class and are resolved at **compile-time** based on the reference type, not the object.

**Key Characteristics of Method Hiding**
1. **Static Context:** It applies only to static methods.
2. **No Polymorphism:** It does not support runtime polymorphism. The method that gets called is determined at compile-time.
3. **Reference Type Matters:** The version of the method that is executed depends on the type of the reference, not the object.

**Example of Method Hiding**
```java
class Parent {
    static void display() {
        System.out.println("Static method in Parent");
    }
}

class Child extends Parent {
    static void display() {
        System.out.println("Static method in Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj1 = new Parent();
        Parent obj2 = new Child();
        Child obj3 = new Child();

        obj1.display(); // Output: Static method in Parent
        obj2.display(); // Output: Static method in Parent (method hiding)
        obj3.display(); // Output: Static method in Child
    }
}

```
**Explanation of the Example**
1. `obj1.display()`: The reference type is `Parent`, so `Parent`'s `display()` method is called.
2. `obj2.display()`: Even though the object is of type `Child`, the reference type is `Parent`, so `Parent`'s `display()` method is called.
3. `obj3.display()`: Both the reference and the object are of type `Child`, so `Child`'s `display()` method is called.

![img_27.png](img_27.png)

**Key Takeaways**
* Static methods cannot be overridden but can be hidden.
* Method hiding depends on the `reference type`, while overriding depends on the `object type`.
* Use method hiding carefully to avoid confusion, as it does not follow the same polymorphic behavior as overriding.

### 34. What is the difference between final, finally, and finalize()?
![img_28.png](img_28.png)

**Detailed Explanation**
1. `final`
- **Purpose**:
   - **Variables**: Prevents reassignment. (Makes the variable a constant.)
   - **Methods**: Prevents overriding by subclasses.
   - **Classes**: Prevents inheritance.

- Example:
```java
final class FinalClass { } // Cannot be subclassed

class Parent {
    final void display() {
        System.out.println("This method cannot be overridden");
    }
}

public class Main {
    public static void main(String[] args) {
        final int number = 10; // Cannot reassign
        // number = 20; // Compilation error
    }
}

```

2. `finally`
- **Purpose**: Used to execute important cleanup code like closing resources, regardless of whether an exception occurred or was caught.
- **Behavior**:
  - Executes after the `try` block, even if there is a `return` statement or an exception in the `try` block.
  
- Example:
```java
public class Main {
    public static void main(String[] args) {
        try {
            int result = 10 / 0; // Exception occurs
        } catch (ArithmeticException e) {
            System.out.println("Exception caught: " + e.getMessage());
        } finally {
            System.out.println("Finally block always executes.");
        }
    }
}

```
3. `finalize()`
- **Purpose**:
   - Called by the garbage collector before destroying an object to allow cleanup of resources.
   - Deprecated in Java 9 due to unpredictability.
- **Usage**: Rarely used. Developers prefer explicit cleanup (e.g., `try-with-resources` or closing resources in `finally`).
   
- Example:
```java
public class Main {
    @Override
    protected void finalize() throws Throwable {
        System.out.println("Finalize method called before garbage collection.");
    }

    public static void main(String[] args) {
        Main obj = new Main();
        obj = null; // Eligible for GC
        System.gc(); // Request garbage collection
    }
}

```
![img_29.png](img_29.png)

**Key Takeaways**
* Use `final` for defining constants, preventing inheritance, or restricting method overriding.
* Use `finally` for resource cleanup during exception handling.
* Avoid relying on `finalize()`; instead, use modern techniques like `try-with-resources` for resource management.

### 35. Can you override a private method in Java?

No, **you cannot override a private method in Java** because private methods are not accessible outside the class in which they are declared.

**Reason**
- **Private methods** are specific to the class they are defined in and are not visible to subclasses or other classes. Since overriding requires the method in the subclass to have the same signature and visibility, private methods cannot participate in this process.

**What Happens If You Declare a Method with the Same Name in a Subclass?**\
If you define a method with the same name in a subclass, it is not an override but a **new method** **specific to the subclass**. This is called **method hiding**, and the subclass method does not affect or override the private method in the superclass.

**Example**
```java
class Parent {
    private void display() {
        System.out.println("Private method in Parent class");
    }
}

class Child extends Parent {
    // This is not overriding; it is a new method
    public void display() {
        System.out.println("Public method in Child class");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent parent = new Parent();
        // parent.display(); // Compilation error: display() has private access in Parent

        Child child = new Child();
        child.display(); // Calls the display() method in Child class
    }
}

```
**Output**
```
Public method in Child class
```
**Key Takeaways:**
1. **Private methods** cannot be overridden because they are not inherited by subclasses.
2. Declaring a method with the same name in a subclass creates a **new method**, not an overridden one.
3. The concept of overriding only applies to methods that are visible to the subclass (e.g., `protected`, `public`).

### 36. Explain the super keyword with an example.

The `super` keyword in Java is used to refer to the **immediate parent class** of the current object. It provides access to:

1. **Parent class members** (fields and methods) that are hidden by the child class.
2. **Parent class constructor** to initialize the parent class.

**Uses of** `super`
1. **Access Parent Class Fields**

    - If a child class defines a field with the same name as a field in the parent class, you can use `super` to access the parent class version.
2. **Invoke Parent Class Methods**

    - If a child class overrides a method in the parent class, you can use `super` to call the parent class method.
3. **Call Parent Class Constructor**

    - Used in the child class constructor to initialize the parent class by explicitly invoking its constructor.

**Example 1: Access Parent Class Fields**
```java
class Parent {
    String name = "Parent Class";
}

class Child extends Parent {
    String name = "Child Class";

    public void displayNames() {
        System.out.println("Child name: " + name); // Access child class field
        System.out.println("Parent name: " + super.name); // Access parent class field
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.displayNames();
    }
}

```
**Output**
```
Child name: Child Class
Parent name: Parent Class
```
**Example 2: Invoke Parent Class Methods**
```java
class Parent {
    public void showMessage() {
        System.out.println("Message from Parent class");
    }
}

class Child extends Parent {
    public void showMessage() {
        System.out.println("Message from Child class");
    }

    public void displayMessages() {
        super.showMessage(); // Calls parent class method
        this.showMessage(); // Calls child class method
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.displayMessages();
    }
}

```
**Output**
```
Message from Parent class
Message from Child class

```
**Example 3: Call Parent Class Constructor**

```java
class Parent {
    public Parent() {
        System.out.println("Parent class constructor called");
    }
}

class Child extends Parent {
    public Child() {
        super(); // Calls Parent class constructor
        System.out.println("Child class constructor called");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
    }
}

```
**Output**
```
Parent class constructor called
Child class constructor called

```
**Key Points**
1. `super` **must be the first statement** in the constructor if you are calling the parent class constructor.
2. You can use `super` to access parent class members, even if they are shadowed by child class members.
3. If you don’t explicitly call the parent class constructor using `super`, Java automatically calls the **default constructor** of the parent class.

### 37. What is the difference between IS-A and HAS-A relationships?
In Java, **IS-A** and **HAS-A** represent two types of relationships between classes. These relationships are foundational for object-oriented programming.

**1. IS-A Relationship**
* Definition: Represents **inheritance** or generalization.
* It is a parent-child relationship where a subclass (child) **inherits** the behavior and properties of a superclass (parent).
* Achieved using the `extends` keyword (for classes) or `implements` keyword (for interfaces).
* Example: "**A Dog IS-A Animal**."

**Key Characteristics:**
* Facilitates code reuse through inheritance.
* Polymorphism is achieved with IS-A.
* Focuses on **what the subclass is**.

**Example**
```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // Inherited method
        dog.bark(); // Specific to Dog class
    }
}

```
**Output**
```
This animal eats food.
Dog barks.
```
**2. HAS-A Relationship**
* **Definition**: Represents **composition** or aggregation.
* It is a relationship where a class contains a reference to another class as a **field**.
* Focuses on **what the class has** rather than what it is.
* Example: "**A Car HAS-A Engine.**"
   
Key Characteristics:
* Used to achieve code reuse without inheritance.
* Helps in designing modular and loosely coupled systems.
* Focuses on **what the class possesses**.

* Example:
```java
class Engine {
    void start() {
        System.out.println("Engine starts.");
    }
}

class Car {
    Engine engine = new Engine(); // Car HAS-A Engine

    void drive() {
        engine.start();
        System.out.println("Car is moving.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.drive();
    }
}

```
**Output**
```
Engine starts.
Car is moving.
```

![img_30.png](img_30.png)

**When to Use IS-A or HAS-A?**
1. **IS-A:**
    - Use when there is a clear parent-child relationship.
    - Example: "A Rectangle IS-A Shape."

2. **HAS-A:**
   - Use when a class requires functionality provided by another class but does not need to inherit it.
   - Example: "A Library HAS-A Collection of Books."

By carefully analyzing the relationship between classes, you can decide whether to use inheritance (IS-A) or composition (HAS-A).

### 38. How do you implement a singleton class in Java?
A **singleton class** ensures that only **one instance** of the class is created and provides a **global point of access** to it. Singleton is widely used in scenarios like logging, caching, thread pools, and configuration settings.

**Key Characteristics of a Singleton Class**
1. Only one instance of the class exists throughout the application.
2. Instance is globally accessible.
3. Class controls its instance creation.

**Steps to Implement a Singleton Class**
1. **Private Constructor:** Restricts instantiation of the class from other classes.
2. **Static Instance Variable:** Holds the single instance of the class.
3. **Public Static Method:** Provides access to the instance.

**1. Eager Initialization**\
   The instance is created at the time of class loading.
```java
class Singleton {
    // Static instance created eagerly
    private static final Singleton INSTANCE = new Singleton();

    // Private constructor
    private Singleton() {}

    // Public method to provide access to the instance
    public static Singleton getInstance() {
        return INSTANCE;
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();

        System.out.println(singleton1 == singleton2); // true
    }
}

```
**Pros:**
* Simple to implement.
* Thread-safe without synchronization.

**Cons:**
- Instance is created even if it's never used, which may waste resources.

**2. Lazy Initialization**\
   Instance is created only when it is needed.
```java
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();

        System.out.println(singleton1 == singleton2); // true
    }
}

```
**Pros:**
    - Instance is created only when needed.
**Cons:**
    - Not thread-safe.

**3. Thread-Safe Singleton**\
   To make lazy initialization thread-safe, synchronize the getInstance() method.

```java
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

```
**Cons:**
- Synchronization can impact performance in multithreaded environments.

**4. Double-Checked Locking**\
   Optimizes the thread-safe implementation.

```java
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) { // First check
            synchronized (Singleton.class) {
                if (instance == null) { // Second check
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```
**Pros:**
- Reduces synchronization overhead.
- Thread-safe and efficient.

**5. Bill Pugh Singleton (Using Inner Static Class)**\
   The most efficient and widely used approach.

```java
class Singleton {
    private Singleton() {}

    // Inner static helper class
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}

```
**Pros:**
* Instance is created lazily and is thread-safe without synchronization.
* Leverages the JVM's class-loading mechanism.

![img_31.png](img_31.png)

**Usage**\
Singletons are used in scenarios where a single shared resource, such as a database connection pool, logging service, or configuration, is needed throughout the application.


### 39. What is the Java Collections Framework?

The **Java Collections Framework (JCF)** is a set of classes and interfaces in Java that provides a standard architecture for managing groups of objects. It includes algorithms and data structures like lists, sets, maps, and queues, making it easier to perform common operations such as sorting, searching, and traversing collections.

**Key Components of the Java Collections Framework**\
**1. Interfaces**\
These define the abstract data types. Some important interfaces are:

* **Collection**: The root interface for most collections.
* **List**: An ordered collection allowing duplicate elements. Example: `ArrayList`, `LinkedList`.
* **Set**: A collection that doesn't allow duplicate elements. Example: `HashSet`, `TreeSet`.
* **Map**: A collection of key-value pairs. Example: `HashMap`, `TreeMap`.
* **Queue**: A collection designed for holding elements before processing. Example: `PriorityQueue`, `LinkedList`.

**2. Implementations (Classes)**\
These are concrete implementations of the interfaces, providing specific functionalities:

* **ArrayList**: A resizable array.
* **LinkedList**: A doubly-linked list.
* **HashSet**: A set backed by a hash table.
* **TreeSet**: A sorted set implemented using a tree structure.
* **HashMap**: A map backed by a hash table.
* **TreeMap**: A sorted map implemented using a red-black tree

**3. Algorithms**\
   Utility methods in the Collections class provide algorithms to operate on collections:

* Sorting (`Collections.sort()`).
* Searching (`Collections.binarySearch()`).
* Shuffling (`Collections.shuffle()`).
* Reversing (`Collections.reverse()`).

**Advantages of the Java Collections Framework**
1. **Unified Architecture:** A common interface allows switching between different data structures without altering the code.
2. **Predefined Methods:** Reduces development time by providing pre-built methods for operations like sorting and searching.
3. **Efficiency**: Collections are optimized for performance.
4. **Flexibility**: Offers a wide variety of data structures tailored to different use cases.
5. **Thread-Safe Options:** Provides classes like Vector and Hashtable and utilities like Collections.synchronizedList() for multi-threaded environments.

**Basic Example: Using List**
```java
import java.util.ArrayList;
import java.util.Collections;

public class Main {
    public static void main(String[] args) {
        // Creating a list
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");

        // Sorting the list
        Collections.sort(list);
        System.out.println("Sorted List: " + list);

        // Searching an element
        int index = Collections.binarySearch(list, "Banana");
        System.out.println("Index of 'Banana': " + index);
    }
}

```
**Output**
```
Sorted List: [Apple, Banana, Orange]
Index of 'Banana': 1

```
**Hierarchy of the Collections Framework**

```
java.util
  ├── Collection
  │     ├── List
  │     │     ├── ArrayList
  │     │     └── LinkedList
  │     ├── Set
  │     │     ├── HashSet
  │     │     └── TreeSet
  │     └── Queue
  │           └── PriorityQueue
  └── Map
        ├── HashMap
        └── TreeMap

```

**Real-World Use Cases**
* **List**: Managing ordered data like a to-do list.
* **Set**: Removing duplicate entries from a data set.
* **Map**: Storing key-value pairs like a dictionary or configuration settings.
* **Queue**: Implementing task schedulers or message queues.

The Java Collections Framework provides a robust foundation for working with data structures, making Java development more efficient and versatile.

### 40. What is the difference between ArrayList and LinkedList?

Both **ArrayList** and **LinkedList** are implementations of the List interface in Java Collections Framework, but they differ in their internal workings, performance, and use cases.

![img_32.png](img_32.png)

**Detailed Explanation with Examples**\
**1. Random Access Performance**
*    **ArrayList** provides constant time `O(1)` access to elements by index since it uses a resizable array.
*    **LinkedList** requires traversing the list `(O(n))`, as elements are not stored contiguously.

**Example**
```java
import java.util.ArrayList;
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> arrayList = new ArrayList<>();
        LinkedList<String> linkedList = new LinkedList<>();

        // Adding elements
        arrayList.add("A");
        linkedList.add("A");

        // Random access
        System.out.println("ArrayList: " + arrayList.get(0)); // Fast
        System.out.println("LinkedList: " + linkedList.get(0)); // Slower
    }
}

```
**2. Insertion Performance**
*    **ArrayList** requires shifting elements when inserting or deleting in the middle of the list.
*    **LinkedList** can insert or delete without shifting but requires node traversal to find the position.

**Example**
```java
import java.util.ArrayList;
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        ArrayList<Integer> arrayList = new ArrayList<>();
        LinkedList<Integer> linkedList = new LinkedList<>();

        // Adding elements to the middle of the list
        for (int i = 0; i < 10000; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }

        long startTime = System.nanoTime();
        arrayList.add(5000, 999); // Slow due to shifting
        long endTime = System.nanoTime();
        System.out.println("ArrayList Insertion: " + (endTime - startTime) + " ns");

        startTime = System.nanoTime();
        linkedList.add(5000, 999); // Fast as no shifting
        endTime = System.nanoTime();
        System.out.println("LinkedList Insertion: " + (endTime - startTime) + " ns");
    }
}

```
**Key Points to Remember**
* Use **ArrayList** when frequent read operations or random access is required.
* Use **LinkedList** when frequent insertions and deletions are needed.
* **Memory considerations:** **ArrayList** uses less memory compared to **LinkedList** due to the absence of node pointers.
* Iterating through **ArrayList** is faster because of contiguous memory.

**Choosing the right data structure depends on your specific use case and performance needs.**

### 41. What is the difference between HashSet and TreeSet?

Both **HashSet** and **TreeSet** are implementations of the Set interface in Java, but they have distinct differences in terms of performance, ordering, and underlying data structures.

![img_33.png](img_33.png)

**Detailed Explanation with Examples**\
**1. Ordering of Elements**
*    **HashSet** does not guarantee any order of the elements, meaning the elements can appear in any random order.
*    **TreeSet**, on the other hand, sorts the elements based on their natural ordering (or by a **Comparator** if provided).
   
**Example:**
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // HashSet (no specific order)
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Banana");
        hashSet.add("Apple");
        hashSet.add("Mango");
        System.out.println("HashSet: " + hashSet); // Output may not be sorted
        
        // TreeSet (sorted order)
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("Banana");
        treeSet.add("Apple");
        treeSet.add("Mango");
        System.out.println("TreeSet: " + treeSet); // Output will be sorted
    }
}

```
**Output**
```
HashSet: [Banana, Apple, Mango]  // The order could vary.
TreeSet: [Apple, Banana, Mango] // Sorted in ascending order.
```
**2. Performance**
*    **HashSet** is backed by a hash table and offers average constant time performance `(O(1))` for the operations like **add**, **remove**, and **contains**.
*    **TreeSet** is backed by a Red-Black tree and offers logarithmic time performance `(O(log n))` for the operations like **add**, **remove**, and **contains** due to the need to maintain sorted order.

**Example**
```java
import java.util.*;

public class PerformanceTest {
    public static void main(String[] args) {
        // Measure time for HashSet
        Set<Integer> hashSet = new HashSet<>();
        long start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            hashSet.add(i);
        }
        long end = System.nanoTime();
        System.out.println("HashSet time: " + (end - start) + " ns");

        // Measure time for TreeSet
        Set<Integer> treeSet = new TreeSet<>();
        start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            treeSet.add(i);
        }
        end = System.nanoTime();
        System.out.println("TreeSet time: " + (end - start) + " ns");
    }
}

```
In this case, **HashSet** will generally perform better for insertions due to its `O(1)` time complexity, while **TreeSet** will take more time due to its `O(log n)` complexity for maintaining order.

**3. Null Values**
*    **HashSet** allows **null** elements (as it does not care about the order).
*    **TreeSet** does **not allow null** elements because it requires a way to compare the elements (to maintain the sorted order), and `null` cannot be compared in this manner.
   
**Example**:
```java
import java.util.*;

public class NullTest {
    public static void main(String[] args) {
        // HashSet allows null
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Apple");
        hashSet.add(null);  // This is allowed
        System.out.println("HashSet with null: " + hashSet);
        
        // TreeSet does not allow null and will throw NullPointerException
        try {
            Set<String> treeSet = new TreeSet<>();
            treeSet.add("Apple");
            treeSet.add(null);  // This will throw NullPointerException
        } catch (Exception e) {
            System.out.println("Exception in TreeSet: " + e);
        }
    }
}

```
**Output**
```
HashSet with null: [Apple, null]
Exception in TreeSet: java.lang.NullPointerException

```
**Key Points to Remember**
* **Use HashSet** when you do not care about sorting and need faster insertion and lookup.
* **Use TreeSet** when you need elements to be sorted (in natural or custom order).
* **TreeSet** has higher time complexity `(O(log n))` for common operations due to sorting, while **HashSet** offers constant time complexity `(O(1))` for common operations, making it more efficient in most cases.

### 42. What is the difference between HashMap and Hashtable?
**HashMap** and **Hashtable** are both used for storing key-value pairs in Java. They are part of the **Java Collections Framework** and implement the **Map** interface. However, they have several differences in terms of synchronization, null values, performance, and other characteristics.

Here is a detailed comparison:
![img_34.png](img_34.png)

**Key Differences in Detail**
**1. Thread Safety**
*    **HashMap** is **not synchronized**, meaning it does not provide built-in thread safety. If multiple threads try to access a HashMap simultaneously, it could lead to inconsistent data unless external synchronization is provided (e.g., using Collections.synchronizedMap or other synchronization mechanisms).
*    **Hashtable**, on the other hand, is **synchronized**. This means only one thread can access a Hashtable at a time, making it inherently thread-safe.

**2. Null Keys and Values**
*    **HashMap** allows **null keys** and **null values**. You can store a null value for any key, and you can store one null key.
```java
HashMap<String, String> hashMap = new HashMap<>();
hashMap.put(null, "Value1");
hashMap.put("Key2", null);

```
* **Hashtable** does **not allow null** for either keys or values. If you try to insert a `null` key or value, it throws a `NullPointerException`.

```java
Hashtable<String, String> hashtable = new Hashtable<>();
hashtable.put(null, "Value1");  // Throws NullPointerException
hashtable.put("Key2", null);    // Throws NullPointerException

```
**3. Performance**
* **HashMap** is generally **faster** than Hashtable. Since it is not synchronized, multiple threads can access it simultaneously, which allows for better performance in single-threaded environments or when synchronization is managed externally.
* **Hashtable** is **slower** because it is synchronized, and thread safety comes at the cost of performance. For every method invocation on a Hashtable, a lock must be acquired, which can become a bottleneck in multi-threaded applications.

**4. Legacy Status**
* **HashMap** is part of the **Java Collections Framework** (introduced in Java 1.2) and is preferred over Hashtable in most scenarios.
* **Hashtable** is part of the **legacy classes** (since JDK 1.0) and has been retrofitted to implement the Map interface. It is considered outdated, and its usage is generally discouraged in modern Java programming in favor of HashMap or other classes.

**5. Iteration**
* **HashMap** uses an **Iterator** for iteration, which is **fail-fast**. If the map is modified during iteration (except through the iterator’s own remove method), a `ConcurrentModificationException` will be thrown.
* **Hashtable** uses an **Enumerator**, which is **not fail-fast**. It does not throw an exception if the map is modified during iteration.

**Code Example:**
```java
import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        // Example of HashMap
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put("1", "One");
        hashMap.put("2", "Two");
        hashMap.put(null, "Null Key");
        hashMap.put("3", null);
        System.out.println("HashMap: " + hashMap);

        // Example of Hashtable
        Map<String, String> hashtable = new Hashtable<>();
        hashtable.put("1", "One");
        hashtable.put("2", "Two");
        // hashtable.put(null, "Null Key");  // Throws NullPointerException
        // hashtable.put("3", null);         // Throws NullPointerException
        System.out.println("Hashtable: " + hashtable);
    }
}

```
**Output**
```
HashMap: {null=Null Key, 1=One, 2=Two, 3=null}
Hashtable: {1=One, 2=Two}
```

### 43.How does a HashMap work internally?

A `HashMap` in Java is a part of the **Java Collections Framework** and implements the `Map` interface. It is used to store key-value pairs, where each key is unique and is mapped to a specific value. Internally, a `HashMap` uses a **hash table** to store the data. Here's a detailed explanation of how it works internally:

**1. Hashing and Hash Functions**\
When a key-value pair is added to a HashMap, the key is first processed by a **hash function** to generate a **hash code**. This hash code determines where the corresponding entry (key-value pair) will be placed in the hash table.

* The **hash code** of the key is calculated using the key’s `hashCode()` method. The hash code is then used to find the corresponding **bucket** in the hash table.
* The **bucket** is essentially an index in the underlying array where the entry will be stored. The bucket index is computed by applying a modulo operation on the hash code to ensure that the index stays within the size of the internal array (i.e., the capacity of the hash table).

```
int index = hashCode(key) % capacity;
```
**2. Buckets**\
The HashMap internally uses an **array** of **buckets**. Each bucket holds a linked list (or another form of storage, depending on Java version) to handle **collisions** (when two different keys hash to the same bucket). The size of this array is dynamic and grows as the map grows, based on its **load factor**.

* **Initial Capacity:** The initial size of the array (default is 16).
* **Load Factor**: The load factor determines when the `HashMap` should resize itself. The default load factor is **0.75**. This means that when the number of elements exceeds 75% of the current capacity, the `HashMap` will resize itself (usually doubling the size of the array).

**3. Collisions and Chaining**\
A **collision** occurs when two different keys hash to the same bucket. To handle this, HashMap uses a technique called **chaining**.

* **Chaining** involves storing multiple entries at the same index (bucket) using a **linked list**. Each entry in the bucket contains the key-value pair along with a reference to the next entry (in case of a collision).
* In recent versions of Java (Java 8 and later), when the number of elements in a bucket exceeds a certain threshold (e.g., 8 elements), the bucket switches from a **linked list** to a **balanced tree (Red-Black Tree)**, which improves the performance of search operations from `O(n)` to `O(log n)` for large chains.


**4. Putting an Entry**\
When a key-value pair is added to a `HashMap`:

1. **Compute the hash code:** The `hashCode()` method of the key is called to compute the hash code.
2. **Determine the bucket index:** The hash code is then used to compute the bucket index `(index = hashCode(key) % capacity)`.
3. **Check for collisions:** If the bucket is empty, the key-value pair is inserted directly. If there is already an entry in the bucket (collision), the `HashMap` will either add the new entry to the end of the linked list (if it is a chain) or create a balanced tree (if the threshold is met).
4. **Resize if necessary:** If the `HashMap` exceeds its load factor, it will **resize** (rehash) and reallocate the elements into a new array of a larger size.

**5. Retrieving a Value**\
To retrieve a value from the `HashMap`:

1. **Compute the hash code:** The hash code of the key is calculated using the key’s `hashCode()` method.
2. **Determine the bucket index:** The index is determined as `index = hashCode(key) % capacity`.
3. **Find the key in the bucket:** The `HashMap` checks the linked list or tree at that bucket index to find the entry with the matching key.
4. **Return the value:** If the key is found, its corresponding value is returned. If not, `null` is returned.

**6. Removing an Entry**\
To remove an entry:
1. **Compute the hash code:** The hash code of the key is computed.
2. **Find the bucket index:** The index for the bucket is determined.
3. **Locate and remove the entry:** The `HashMap` searches the bucket for the key. If found, the entry is removed from the linked list or tree.

**Example of How HashMap Works Internally**
```java
import java.util.*;

public class HashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        
        map.put("A", 1);  // Key "A" will be hashed and mapped to a bucket
        map.put("B", 2);  // Key "B" will be hashed and mapped to a bucket
        map.put("C", 3);  // Key "C" will be hashed and mapped to a bucket
        
        // Retrieving the value
        System.out.println("Value for key 'A': " + map.get("A"));  // Output: 1
        System.out.println("Value for key 'B': " + map.get("B"));  // Output: 2
    }
}

```
**HashMap Internal Data Structure**
1. **Array of Buckets:** The `HashMap` internally uses an array of buckets to store entries. The size of the array is dynamically increased when the load factor threshold is crossed.
2. **Entry Object:** Each element in the bucket is an Entry object that contains:
   - Key
   - Value
   - Hash code of the key
   - Reference to the next Entry (for chaining/collisions)
   
**Performance Considerations**\
- **Time Complexity:**
  - **Average case:** The time complexity for **get** and **put** operations is `O(1)` in the average case, due to the hash-based structure.
  - **Worst case:** In the case of many collisions (if the hash function is poor), the time complexity can degrade to `O(n)`, where n is the number of elements in the bucket. However, Java 8 introduced the balanced tree mechanism to mitigate this for large chains.

- **Space Complexity:** The space complexity of a `HashMap` is` O(n)`, where n is the number of key-value pairs.

### 44. What are fail-fast and fail-safe iterators?

In Java, iterators are used to iterate over collections such as `List`, `Set`, or `Map`. **Fail-fast** and **fail-safe** are two types of iterators, and they differ in how they handle changes (such as modifications) made to the collection during iteration.

**1. Fail-fast Iterator**\
   A **fail-fast** iterator immediately throws a `ConcurrentModificationException` if the collection is modified (structurally changed) while it is being iterated. Structural changes refer to adding, removing, or changing elements in the collection.

**Behavior:**
* **Modifications during iteration:** If the collection is modified after the iterator is created, the fail-fast iterator will detect this and throw a `ConcurrentModificationException`.
* **Example:** This happens if you modify the collection while using an iterator directly (e.g., by adding or removing elements from the collection).

**Example of fail-fast behavior:**

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class FailFastExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        
        Iterator<String> iterator = list.iterator();
        
        // Modifying the collection while iterating will cause a ConcurrentModificationException
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if (fruit.equals("Banana")) {
                list.remove(fruit);  // This modification will throw ConcurrentModificationException
            }
        }
    }
}

```
**Why it happens:**
- The **modCount** variable is used to track the number of structural changes made to the collection. If it changes while the iterator is active, it signals that the collection has been modified and a `ConcurrentModificationException` is thrown to prevent unpredictable behavior.

**Collections that use fail-fast iterators:**
* ArrayList
* HashMap
* HashSet
* LinkedList

**2. Fail-safe Iterator**\
   A **fail-safe** iterator does not throw an exception if the collection is modified during iteration. Instead, it operates on a copy of the collection, so changes made to the original collection during iteration do not affect the iteration process.

**Behavior:**
* **Modifications during iteration:** Modifying the collection while iterating over it will not affect the fail-safe iterator. The iterator uses a copy of the collection, which ensures that structural changes do not interfere with the ongoing iteration.
* **Example:** The `ConcurrentHashMap` and `CopyOnWriteArrayList` are examples of collections that use fail-safe iterators.

**Example of fail-safe behavior:**
```java
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Iterator;

public class FailSafeExample {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        Iterator<String> iterator = list.iterator();
        
        // Modifying the collection while iterating will NOT cause an exception
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if (fruit.equals("Banana")) {
                list.remove(fruit);  // This modification will NOT throw ConcurrentModificationException
            }
        }

        // Output the list to see that the change was reflected
        System.out.println(list);  // Output: [Apple, Cherry]
    }
}

```
**Why it happens:**
- In **fail-safe** collections, a copy of the collection is iterated over, meaning any modifications (additions or deletions) to the original collection during iteration do not affect the current iteration process. Therefore, no exceptions are thrown.

**Collections that use fail-safe iterators:**
* CopyOnWriteArrayList
* CopyOnWriteArraySet
* ConcurrentHashMap
* BlockingQueue classes

![img_35.png](img_35.png)

**When to Use:**
* **Fail-fast** iterators are suitable when you are not dealing with concurrent modifications and need a fast, efficient iteration.
* **Fail-safe** iterators are useful in multi-threaded environments where collections might be modified by different threads during iteration. However, they can come at a cost in terms of performance due to creating copies of collections.

### 45. What is the difference between Iterator and ListIterator?

The main difference between **Iterator** and **ListIterator** in Java lies in their functionality and the types of collections they can iterate over. Here's a detailed explanation:

**1. Iterator:**\
An `Iterator` is the most basic interface used to iterate over a collection. It provides methods to traverse through any **Collection** (such as `List`, `Set`, `Queue`) in a forward direction only.

**Key Features of Iterator:**
* **Traversal Direction:** It allows only **forward** traversal, meaning you can only iterate through the collection in one direction (from beginning to end).
* **Methods:**
  - `hasNext()`: Returns `true` if there are more elements to iterate through.
  - `next()`: Returns the next element in the collection and advances the iterator.
  - `remove()`: Removes the last element returned by the iterator (optional operation).

- **Applicable Collections:** Can be used for **any** type of collection, including `List`, `Set`, and `Queue`.
  
**Example**:
```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class IteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        Iterator<String> iterator = list.iterator();
        
        // Iterating in forward direction
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}

```
**2. ListIterator:**\
   `ListIterator` is a more advanced version of the `Iterator` interface, designed specifically for the `List` interface. It allows bidirectional traversal of a list (both forward and backward).

**Key Features of ListIterator:**
* **Traversal Direction:** It supports both forward and backward traversal. You can move to the next element or move backwards to the previous element.
* **Methods:**
  - `hasNext()`: Returns `true` if there are more elements in the forward direction.
  - `next()`: Returns the next element in the forward direction and advances the iterator.
  - `hasPrevious()`: Returns `true` if there are more elements in the backward direction.
  - `previous()`: Returns the previous element and moves the iterator backward.
  - `add(E e)`: Adds an element to the list at the current position.
  - `set(E e)`: Replaces the last element returned by `next()` or `previous()` with the specified element.
  - `remove()`: Removes the last element returned by the iterator (optional operation).
  
- **Applicable Collections:** `ListIterator` can only be used with `List` collections (such as `ArrayList`, `LinkedList`, etc.).

**Example**:
```java
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class ListIteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        ListIterator<String> listIterator = list.listIterator();

        // Iterating in forward direction
        while (listIterator.hasNext()) {
            System.out.println(listIterator.next());
        }

        System.out.println("----");

        // Iterating in backward direction
        while (listIterator.hasPrevious()) {
            System.out.println(listIterator.previous());
        }
    }
}

```
![img_37.png](img_37.png)











